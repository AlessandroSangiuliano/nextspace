--- ./WindowMaker-0.95.7/src/event.c	2015-08-11 21:41:14.000000000 +0300
+++ ./WindowMaker/src/event.c	2018-07-10 15:46:09.732264497 +0300
@@ -80,6 +80,9 @@
 #include "switchmenu.h"
 #include "wsmap.h"
 
+#ifdef NEXTSPACE
+#include <Workspace+WindowMaker.h>
+#endif
 
 #define MOD_MASK wPreferences.modifier_mask
 
@@ -90,6 +93,10 @@
 static void handleMapNotify(XEvent *event);
 static void handleUnmapNotify(XEvent *event);
 static void handleButtonPress(XEvent *event);
+#ifdef NEXTSPACE
+static void handleButtonRelease(XEvent * event);
+static void handleKeyRelease(XEvent * event);
+#endif
 static void handleExpose(XEvent *event);
 static void handleDestroyNotify(XEvent *event);
 static void handleConfigureRequest(XEvent *event);
@@ -209,6 +216,11 @@
 		handleKeyPress(event);
 		break;
 
+#ifdef NEXTSPACE
+	case KeyRelease:
+		handleKeyRelease(event);
+		break;
+#endif
 	case MotionNotify:
 		handleMotionNotify(event);
 		break;
@@ -237,6 +249,11 @@
 		handleExpose(event);
 		break;
 
+#ifdef NEXTSPACE
+	case ButtonRelease:
+		handleButtonRelease(event);
+          break;
+#endif
 	case PropertyNotify:
 		handlePropertyNotify(event);
 		break;
@@ -580,9 +597,15 @@
 		 * XRRUpdateConfiguration when screen configuration change notify
 		 * events are generated */
 		XRRUpdateConfiguration(event);
+#ifdef NEXTSPACE                
+		for (int i = 0; i < w_global.screen_count; i++) {
+			XWUpdateScreenInfo(wScreenWithNumber(i));
+		}
+#else
 		WCHANGE_STATE(WSTATE_RESTARTING);
 		Shutdown(WSRestartPreparationMode);
 		Restart(NULL,True);
+#endif
 	}
 #endif
 }
@@ -670,6 +693,9 @@
 
 	wwin = wWindowFor(window);
 	if (wwin) {
+#ifdef NEXTSPACE
+		dispatch_sync(workspace_q, ^{ XWApplicationDidCloseWindow(wwin); });
+#endif
 		wUnmanageWindow(wwin, False, True);
 	}
 
@@ -803,17 +829,48 @@
 
 	scr = wScreenForRootWindow(event->xbutton.root);
 
+#ifdef NEXTSPACE
+  // reset current focused window button beacuse ButtonPress may change focus
+	WWindow *wwin = scr->focused_window;
+	if (wwin && wwin->client_win != scr->no_focus_win &&
+			wwin->frame->left_button &&
+			event->xbutton.window != wwin->frame->left_button->window &&
+			wwin->frame->right_button &&
+			event->xbutton.window != wwin->frame->right_button->window) {
+		scr->flags.modifier_pressed = 0;
+		wWindowUpdateButtonImages(wwin);
+	}
+#endif
+
 #ifdef BALLOON_TEXT
 	wBalloonHide(scr);
 #endif
 
 	if (!wPreferences.disable_root_mouse && event->xbutton.window == scr->root_win) {
 		if (event->xbutton.button == Button1 && wPreferences.mouse_button1 != WA_NONE) {
+#ifdef NEXTSPACE
+			if (scr->focused_window && scr->focused_window->flags.is_gnustep) {
+				XSendEvent(dpy, scr->focused_window->client_win, False, ButtonPressMask, event);
+			}
+			else {
+				XSendEvent(dpy, scr->dock->icon_array[0]->icon->icon_win, False, ButtonPressMask, event);
+			}
+#else
 			executeButtonAction(scr, event, wPreferences.mouse_button1);
+#endif
 		} else if (event->xbutton.button == Button2 && wPreferences.mouse_button2 != WA_NONE) {
 			executeButtonAction(scr, event, wPreferences.mouse_button2);
 		} else if (event->xbutton.button == Button3 && wPreferences.mouse_button3 != WA_NONE) {
+#ifdef NEXTSPACE
+			if (scr->focused_window && scr->focused_window->flags.is_gnustep) {
+				XSendEvent(dpy, scr->focused_window->client_win, False, ButtonPressMask, event);
+			}
+			else {
+				XSendEvent(dpy, scr->dock->icon_array[0]->icon->icon_win, False, ButtonPressMask, event);
+			}
+#else
 			executeButtonAction(scr, event, wPreferences.mouse_button3);
+#endif
 		} else if (event->xbutton.button == Button8 && wPreferences.mouse_button8 != WA_NONE) {
 			executeButtonAction(scr, event, wPreferences.mouse_button8);
 		}else if (event->xbutton.button == Button9 && wPreferences.mouse_button9 != WA_NONE) {
@@ -839,15 +896,12 @@
 	if (desc->parent_type == WCLASS_WINDOW) {
 		XSync(dpy, 0);
 
-		if (event->xbutton.state & ( MOD_MASK | ControlMask )) {
+		if (event->xbutton.state & ( MOD_MASK | ControlMask)) {
+			XAllowEvents(dpy, AsyncPointer, CurrentTime);
+		} else if (wPreferences.ignore_focus_click) {
 			XAllowEvents(dpy, AsyncPointer, CurrentTime);
 		} else {
-			/*      if (wPreferences.focus_mode == WKF_CLICK) { */
-			if (wPreferences.ignore_focus_click) {
-				XAllowEvents(dpy, AsyncPointer, CurrentTime);
-			}
 			XAllowEvents(dpy, ReplayPointer, CurrentTime);
-			/*      } */
 		}
 		XSync(dpy, 0);
 	} else if (desc->parent_type == WCLASS_APPICON
@@ -873,6 +927,25 @@
 	}
 }
 
+#ifdef NEXTSPACE
+static void handleButtonRelease(XEvent * event)
+{
+	WScreen *scr = wScreenForRootWindow(event->xbutton.root);
+
+  /* fprintf(stderr, "[handleButtonRelease] window:%lu\n", event->xbutton.window); */
+
+	if (!wPreferences.disable_root_mouse && event->xbutton.window == scr->root_win
+			&& event->xbutton.button == Button3) {
+		if (scr->focused_window && scr->focused_window->flags.is_gnustep) {
+			XSendEvent(dpy, scr->focused_window->client_win, True, ButtonReleaseMask, event);
+		}
+		else {
+			XSendEvent(dpy, scr->dock->icon_array[0]->icon->icon_win, False, ButtonReleaseMask, event);
+		}
+	}
+}
+#endif
+
 static void handleMapNotify(XEvent * event)
 {
 	WWindow *wwin;
@@ -1146,6 +1219,9 @@
 		}
 	}
 
+  /* fprintf(stderr, "[EnterNotify] window:%lu subwindow:%lu\n", */
+  /*         event->xcrossing.window, event->xcrossing.subwindow); */
+  
 	if (XFindContext(dpy, event->xcrossing.window, w_global.context.client_win, (XPointer *) & desc) != XCNOENT) {
 		if (desc->handle_enternotify)
 			(*desc->handle_enternotify) (desc, event);
@@ -1210,6 +1286,9 @@
 {
 	WObjDescriptor *desc = NULL;
 
+  /* fprintf(stderr, "[LeaveNotify] window:%lu subwindow:%lu\n", */
+  /*         event->xcrossing.window, event->xcrossing.subwindow); */
+  
 	if (XFindContext(dpy, event->xcrossing.window, w_global.context.client_win, (XPointer *) & desc) != XCNOENT) {
 		if (desc->handle_leavenotify)
 			(*desc->handle_leavenotify) (desc, event);
@@ -1385,10 +1464,33 @@
 #ifdef KEEP_XKB_LOCK_STATUS
 	XkbStateRec staterec;
 #endif				/*KEEP_XKB_LOCK_STATUS */
-
 	/* ignore CapsLock */
 	modifiers = event->xkey.state & w_global.shortcut.modifiers_mask;
 
+#ifdef NEXTSPACE
+  fprintf(stderr, "[WindowMaker] handleKeyPress: %i state: %i mask: %i modifiers: %i\n",
+          event->xkey.keycode, event->xkey.state, MOD_MASK, modifiers);
+  /* fprintf(stderr, "[WindowMaker] no_focus: %lu event: %lu focused: %lu frame: %lu\n", */
+  /*         scr->no_focus_win, event->xkey.window, wwin->client_win, wwin->frame->core->window); */
+  /* fprintf(stderr, "[WindowMaker] handleKeyPress: XK_Super_L == %i XSuper_R == %i\n", */
+  /*         XKeysymToKeycode(dpy, XK_Super_L), XKeysymToKeycode(dpy, XK_Super_R)); */
+	if (((event->xkey.keycode == XKeysymToKeycode(dpy, XK_Super_L)) ||
+       (event->xkey.keycode == XKeysymToKeycode(dpy, XK_Super_R))) &&
+			modifiers == 0) {
+    if (wwin && wwin->client_win != scr->no_focus_win &&
+        event->xkey.window != event->xkey.root) {
+      scr->flags.modifier_pressed = 1;
+      wWindowUpdateButtonImages(wwin);
+    }
+		return;
+	}
+	else if (event->xkey.window != event->xkey.root &&
+           event->xkey.window != scr->no_focus_win) {
+		scr->flags.modifier_pressed = 0;
+		wWindowUpdateButtonImages(wwin);
+	}
+#endif
+
 	for (i = 0; i < WKBD_LAST; i++) {
 		if (wKeyBindings[i].keycode == 0)
 			continue;
@@ -1866,11 +1968,56 @@
 #endif	/* KEEP_XKB_LOCK_STATUS */
 	}
 }
-
+#ifdef NEXTSPACE
+static void handleKeyRelease(XEvent * event)
+{
+	WScreen *scr = wScreenForRootWindow(event->xkey.root);
+	WWindow *wwin = scr->focused_window;
+  
+  if (event->xkey.window == event->xkey.root ||
+      event->xkey.window == scr->no_focus_win) {
+    return;
+  }
+  /* fprintf(stderr, "[WindowMaker] handleKeyRelease: %i state: %i mask: %i\n", */
+  /*         event->xkey.keycode, event->xkey.state, MOD_MASK); */
+	if ( (event->xkey.keycode == XKeysymToKeycode(dpy, XK_Super_L)) ||
+       (event->xkey.keycode == XKeysymToKeycode(dpy, XK_Super_R)) ) {
+    if (wwin) {
+      scr->flags.modifier_pressed = 0;
+      wWindowUpdateButtonImages(wwin);
+    }
+  }
+}
+#endif
 static void handleMotionNotify(XEvent * event)
 {
 	WScreen *scr = wScreenForRootWindow(event->xmotion.root);
 
+#ifdef NEXTSPACE
+	WWindow *wwin = wWindowFor(event->xmotion.window);
+
+	if (event->xmotion.state == 0 || wwin == NULL) {
+		return;
+	}
+
+	if (event->xmotion.state & Button1Mask &&
+			XGrabPointer(dpy, event->xmotion.window, False,
+									ButtonMotionMask | ButtonReleaseMask | ButtonPressMask,
+									GrabModeAsync, GrabModeAsync, None, None, CurrentTime) == GrabSuccess) {
+		/* wMouseMoveWindow checks for button on ButtonRelease event inside it's loop */
+		event->xbutton.button = Button1;
+		if (event->xmotion.window == wwin->frame->titlebar->window ||
+				event->xmotion.state & MOD_MASK) {
+			/* move the window */
+			wMouseMoveWindow(wwin, event);
+		}
+		else if (event->xmotion.window == wwin->frame->resizebar->window) {
+			wMouseResizeWindow(wwin, event);
+		}
+		XUngrabPointer(dpy, CurrentTime);
+	}
+#endif
+
 	if (wPreferences.scrollable_menus) {
 		WMPoint p = wmkpoint(event->xmotion.x_root, event->xmotion.y_root);
 		WMRect rect = wGetRectForHead(scr, wGetHeadForPoint(scr, p));
