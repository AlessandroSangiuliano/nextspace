* NEXTSPACE

** Что нужно для релиза
   - [ ] Старт ОС с отображением прогресса загрузки (с сообщениями)
   - [ ] Запуск Xorg с обнаруженными/сконфигурированными мониторами
     Включая загрузку сохраненной конфигурации. - NXSystem->NXDisplay.
   - [X] Вход по login/password - LoginWindow.app
   - [X] Десктоп с Window и Workspace Manager - Workspace.app
   - [ ] Возможность настройки важных параметров (шрифты, дисплей, клава,
     мышь, звук) - NXSystem.framework, Preferences.app
   - [ ] Простой текстовый редактор - TextEdit.app
   - [ ] Простой просмотрщик картинок - Review.app
   - [ ] Терминал для всяких админских штучек
   - [ ] Полное визуальное соответствие и взаимодействие между WindowMaker и
     GNUstep (miniwindow, fonts hinting, DnD, icon placement и т.д.)
   - [ ] В frameworks должны быть реализованы все TODO класса #A.


** Возможные контексты
*** Запуск ОС
**** Отображение boot screen
***** TODO Придумать тему для plymouth (вид, анимация)
***** TODO Реализовать новую тему для plymouth
***** TODO Сделать RPM-пакет с темой NEXTSPACE для plymouth
**** Старт Xorg и Login.app
***** TODO Применить сохраненный Display Layout
***** TODO Реагировать на подключение/отключение мониторов
***** TODO Затенять экран по тайм-ауту
***** TODO Запускать screensaver по тайм-ауту

*** Desktop
**** Взаимодействие Workspace и WindowMaker
**** File manager
**** Workspace Manager
***** Переключение между Workspaces
***** Сочетания клавиш для управления окнами
**** Мониторы и дисплеи
**** Звук
**** Сеть
**** Утилиты
***** Погодный апплет
***** Монитор утиолизации системных ресурсов
**** Look and feel
***** GNUstep: color mouse cursors, pass click
***** Fonts: default fonts, Font Panel, font prefs in Preferences.app
***** Miniwindows (font, placing)
***** Pass mouse click
***** Drag and Drop Workspace<->Dock
*** Многомониторные конфигурации
**** Applying default layout on startup by Login.app
     Default layout use arranged monitors lined up in horizontal direction.
     Stored in /usr/NextSpace/Preferences/Displays.ospl.
**** Configuring layout in Preferences.app
***** Implement bundle management in NXFoundation/NXBundle
***** Use new NXBundle in Preferences
***** Implement 'Display' 
      ...and store layout in ~/Library/Preferences/.NS/Displays.ospl
**** Applying user layout by Workspace after login
     Read ~/Library/Preferences/.NS/Displays.ospl and apply via 
**** Place WindowMaker elements wrt layout
     Dock, miniwindows, panels.
**** Place GNUstep elements wrt layout
     Application menu, windows.

*** Startup
    - Boot screen
    - Login: NXScreen, Login
    - Desktop: Workspace-Login-WindowMaker interaction (autostart, logout, 
      shutdown)

*** Functionality completeness
    - Startup, shutdown, sleep, hibernate
    - Security: lock screen, screensaver
    - Configuration: sound, network, displays (multiple monitors and video 
      cards), keyboard, power
    - Monitoring and management: sound, network, displays

*** Activities
    - Text editing: TextEdit application
    - Images: view, smple edit, cataloging (tags, annotations)
    - Sounds: listen music, edit and convert encoding of MP3 tags
    - Movies: view, viewt attributes (format, length, frame size, audio tracks)
    - Programming: debuger, editor, navigation, refactoring -> ProjectCenter


** Текущий видимый план
   1. NXSsystem-NXScreen
   2. NXFoundation-NXBundle
   3. Application-Preferences-Display
   4. Applications-Worksapce-Реакция на изменение настроек дисплеев


** Use cases
*** TODO Look & feel
*** TODO Media (usb disks, fixed disks, phone, mp3 player, SDHC)
*** TODO Displays
*** TODO Keyboard
*** TODO Mouse
*** TODO Sound
*** TODO Power management and screensaver
*** TODO Networking


** Packages
   - llvm-3.8.0
   - clang-3.8.0
   - libdispatch-1.3 (rename to nextspace-dispatch?)
   - libobjc2-1.8.2 (rename to nextspace-objc2?)
   - nextspace-core (rename to nextspace-runtime?):
     - gnustep-make (/Developer, openapp, gnustep-config)
     - /etc: X11/Xresources, ld.so.conf.d, profile.d, udev
     - /usr/etc/skel
     - /usr/NextSpace/bin/GNUstepServices
   - nextspace-gnustep: 
     - gnustep-base
     - gnustep-gui
     - gnustep-back
     - /usr/NextSpace/lib/systemd/gdomap.service
     - /usr/NextSpace/lib/systemd/gdnc.service
     - /usr/NextSpace/lib/systemd/gpbs.service
     - /usr/NextSpace/etc/gdomap.interfaces
   - nextspace-frameworks:
     - NXSystem
     - NXFoundation
     - NXAppKit: /usr/NextSpace/Images, /usr/NextSpace/Fonts


* Linux - CentOS 7

** Изменения, которые я внес
** DONE Start/stop скрипты для сервисов GNUstep
*** DONE При старте системы
    Если сервис нормально не останавливется с помощью unit'а systemd,
    система ждет определенный timeout после чего всем шлет сигнал.
*** DONE При входе пользователя (Login)
    В systemd есть какое-то управление пользовательскими сессиями.
    Полезное: https://wiki.archlinux.org/index.php/Systemd/User
    Финал: в CentOS 7 за каким-то чудом эта функциональность убрана
    патчем!
    Принимаю как есть - запуск через скрипты.
** DONE Login
*** DONE При старте нужно устанавливать мышиный курсор для RootWindow
** DONE Workspace
*** DONE Info Panel
**** DONE Processor:
     Нужно парсить /proc/cpuinfo
**** DONE Memory:
     Нужно парсить /proc/meminfo
*** DONE Preferences
**** DONE Shelf -> Resizable Shelf работает наоборот
*** DONE File Viewer
**** DONE Label с размером диска расположено слишком низко
**** DONE SplitView работает нкорректно

*** DONE Операции с файлами в и вне Workspace
** TODO Разное
*** TODO Добавить поддержку UDF, UFS и разметки OPENSTEP-CD
*** TODO Куда-то прописать параметры монтирования EXT2/3/4
    ...сейчас монтируется с правами пользователя, с которыми была создана. В
    результате, на такой внешний диск ничего нельзя записать/удалить. Да и
    ходить по такому диску нельзя.

*** TODO Звук
    Кроме ALSA еще нужен PulseAudio, поскольку его например использует Flash.
    Хотя мнго приложений позволяют выбирать, что использовать.
    У PulseAudio есть достаточно плюшек (Bluetooth, множество устройств
    одновременно, поддержка настроек для каждого приложения и т.д.), чтобы
    использовать именно ее.

    Звук в mplayer какой-то отстойный...

    Кнопки изменения звука на ноутбуке не работают.
    Если горит лампочка на кнопке "F1" (mute) помогает команда:
    pactl set-sink-mute 1 0
    Зажечь лампочку еще раз можно так:
    pactl set-sink-mute 1 1
    Команда 'pactl' управляет PulseAudio.

*** TODO Сеть
    По сути, вся настройка идет через NetworkManager. С ним, похоже, и
    придется иметь дело...

*** TODO Видео
    Для того, чтобы работали кнопки управления яркостью дисплея на ноутбуке
    нужно в командную строку ядра добавить 'acpi_backlight=vendor'.
    http://www.thinkwiki.org/wiki/LCD_Brightness
**** TODO Intel/Nvidia (Bumblebee? Prime?)
**** TODO VDPAU
     Firefox вот так ругается:

     Failed to open VDPAU backend libvdpau_i965.so: cannot open shared object
     file: No such file or directory 

*** DONE Питание
    При закрытии крышки засыпает.
    tuned, udisks2, upower
    Решение: LidSwitchIgnoreInhibited=no в 
    /usr/lib/systemd/logind.conf.d/lidswitch.conf.
    Файл добавлен в nextspace-core.rpm.


* GNUstep

** TODO Клик внутри неактивного окна не обрабатывается subview
   ...или не передается subview окном. NSFistResponder chain?
** TODO Font Panel resizing
   После увеличения размера колонки разъезжаются.
** TODO Сделать мышиный курсор по настоящему цветным
   Для этого можно взять оригинальные курсоры из Workspace Manager.
** TODO Скроллинг у cairo-back работает быстрее art-back
   Это можно проверить на примере: загрузить большую картинку в Review и 
   подергать скролл-бары. Посмотреть на то, как перерисовывается картинка
   в NSImageView.
** TODO Какая-то фигня с чтением PNG
   Изображения с DPI отличным от 72x72 обрабатываются некорректно - меняется
   размер. Именно поэтому некоторые PNG-файлы отображаются коряво.
** TODO DnD
*** TODO Операция по-умолчанию должна быть Copy
*** DONE Кнопка, которая меняет тип операции
    Сейчас это только SecondRightAlternate. 
    Это неправильно должен работать любой Alternate.
    Хм... Сейчас работает и правый и левый.
** TODO Новые версии компонент GNUstep (base, gui, back)
   Пока ставить нельзя - сейчас творится какая-то хрень (в Workspace все
   посъезжало, splitview не работает, может что-то еще).
   Пока остаемся на стабильной версии, которая выпущена летом 2015-го.
** DONE Шрифт у иконки нечитаемый
   В WindowMaker и приложений GNUstep должны быть одинаковые шрифты
   у minwindow.
** DONE Font Panel какой-то неадекватный
   Отображение глючит. Кнопки нужно нажимать чуть выше, чтобы попасть...
   Решил патчем в gnustep-back XGServerWindow.m
** DONE back-art
   Падает при попытке сделать скриншот части окна (view).
   С cairo все в порядке.
   Сначала сделал патч на XGServerWindow, потом при сборке RPM обратил
   внимание, что перестало падать. Подобрал правильные флаги при сборке?


* Frameworks

** TODO NXAppKit
   additions to and modification of AppKit classes
*** DONE NXIcon
*** DONE NXIconLabel
*** DONE Перевести сокращение текста на функцию в NXUtilities
*** DONE NXIconView
**** TODO -checkWrapDown что-то непонятное делает с размером view
*** DONE NXSplitView
   Modified NSSplitView:
      + different divider size (e.g. 12px);
      + configurable resizing constrains.
*** DONE Progress bar, pie (NXProgress*)
*** DONE NXSizer (moved from Workspace)
*** DONE NXNumericField
   Базовая функциональность реализована.
   Добавить:
   - при вводе '.':
     - перемещать курсор перед следующей цифрой;
     - выделять блок цифр (для целых все, для float перед или после точки);
   - не удалять '.' клавишами Delete и Backspace.
*** DONE NXClockView
**** DONE При пустом NSLanguages Attributes Inspector падает
**** DONE Держать картинки в одном TIFF или PNG, как в OPENSTEP
**** DONE Создать тестовый модуль в NXAppKitDemo.
    В этом модуле нужно, чтобы можно было:
    - вводить произвольное время и дату;
    - выбрать язык для отображения месяца и дня недели.
    Может сразу реализовать календарь для Date.preferences?
**** DONE Добавить языков
      Сделать картинки с днями недели и месяцами для разных языков (.lproj).
****** DONE English French, German, Italian, Spanish
       clockbits.tiff из OPENSTEP.
****** DONE Ukrainian
****** DONE Russian
****** DONE Dutch
****** DONE Slovak
****** DONE Hungarian
**** DONE Расстояния между цифрами
      Сейчас цифры близко прижимаются друг к другу.
      Выбрать визуально оптимальный вариант.
      В clockbits.tiff есть 2 строки с цифрами времени:
      - верхняя - расстояние между цифрами одинаковое независимо от цифры;
      - нижняя - похоже на моноширинный шрифт.
      Может нижняя для режима 24-clock? Нужно проверить как это сделано
      в OPENSTEP. Проверил - в обоих режимах расстояние между цифрами
      одинаковое - цифры плотно прижаты друг к другу.
**** DONE Реагировать на изменение глобальных настроек
      ~/LibraryPreferences/.NextSpace/NXGlobalDomain - NXClockView24HourFormat
**** DONE Рисовать год как картинку
**** DONE Оптимизировать рисование (drawRect:)
      Обновлять только те части, которые изменились.
      Обнаружил, что вне зависимости от того, что рисуется в -drawRect: на
      экране отображаются только те изменения, которые передаются для
      обновления в -displayRect:. Это нужно запомнить!
**** DONE Сделать отключаемое мигание точек в часах
     По умолчанию - точки не должны мигать.
**** DONE Добавить возможность загрузки clockbits снаружи
     Получается громоздко и некрасиво. Лучше сделать subclass и override
     initWithFrame: и drawRect: в этом subclass.
*** TODO NXAlertPanel
    Modified NSRunAlertPanel()
*** TODO NXSavePanel, NXOpenPanel
    Standard panels without icons, dirs-first sorting, without
    keyboard focus in browser etc.
*** TODO NXFindPanel
    Generic find/replace panel
     - find/replace panel for text (for editors, help panel etc.);
     - find/replace view to incorporate as subview.
*** Version 2.0
**** TODO NXHelpPanel
     OpenStep's NSHelpPanel implementation


** TODO NXFoundation
   ...additions to and modification of Foundation classes
*** TODO Version 1.0
**** TODO NXBundle
***** TODO Сортировать по полю 'priority'
      Сделано в Preferences, поскольку NXBundle возвращает NSDictionary.
      Нужно возвращать NSArray, тогда его можно будет отсортировать.
***** DONE Проверять дубли при регистрации
***** DONE Clever bundle search
      По итогу: 
      - информация о бандлах может быть получена без загрузки; для
        этого в каждом должен быть файл bundle.registry с необходимой
        информацией.
      - поиск бандлов может быть по-умолчанию в Library, Applications доменов
        SYSTEM, LOCAL и пользовательском.
      - поиск может быть сужен путем указания каталога при вызове
        registerBundlesOfType:atPath: и loadBundlesOfType:protocol:inDirectory.
      - все остальное может появится после использования реализованных методов
        в приложениях (что-может быть востребованно в разных приложениях).     
****** DONE bundle.registry
****** DONE Поиск в /Applications, ~/Applications
****** DONE Поиск в /Library/Bundles
       Поиск в /Libray и ~/Library рекурсивный, поэтому объекты в Bundles тоже
       будут находиться.
**** TODO NXDefaults
     Reading/writing preferences (см. "Размещать файлы...").
***** TODO Приложения перестали сохранять настройки
      Возможно это связано с тем, что в NXDefaults не выполняется synchronize
      после каждого изменения/записи.
***** DONE Размещать файлы NextSpace в ~/Library/Preferences/.NextSpace
****** /Мысли
       Тогда не нужно будет мучиться с расширением - стандартные настройки
       GNUstep ложаться в ~/Library/Preferences, настройки NextSpace в
       ~/Library/Preferences/.NextSpace.
       Например, для Workspace:
       - ~/Library/Preferences/Workspace.plist - то, что GNUstep пишет сам
         (размеры и положения окон, и т.д.;
       - ~/Library/Preferences/.NextSpace/Workspace - параметры Shelf,
         сохраненные открытые окна, настройеки сортировки и т.д.

       Аналогично, можно для WindowMaker складываеть все его файлы настроек в
       ~/Library/Preferences/.WindowMaker - пользователю этот каталог видеть не
       нужно, мне не нужно вливать настройки WindowMaker в какие-либо файлы
       настроек NextSpace (.NextSpace).

****** DONE Размещать файлы настроек WindowMaker в ~/L/P/.WindowMaker
       Содержимое ~/Library/Preferences/.WindowMaker:
         - WindowMaker
         - WMGLOBAL
         - WMRootMenu
         - WMState
         - WMWindowAttributes           

****** DONE По-умолчанию размещать файлы в ~/L/P/.NextSpace
******* DONE Displays*.config - мультимониторные конфигурации
******* DONE NXGlobalDomain
        Глобальные настройки для приложений и фреймворков NextSpace: 
        NXClockView24Hour, клавиатура, мышь, сеть, звук и т.д.
******* DONE Настройки приложений
        Настройки приложений, которые пишутся через NXDefaults (формат
        OPENSTEP, без расширения). GNUstep почему-то не очень хорошо
        работает если все настройки храняться в этом формате. 
        Пока будет так.
****** DONE Слать notification при изменении ~/L/P/.NextSpace/NXGlobalDomain
**** DONE NXFileManager - customized methods for manipulating files/dirs
     Пока реализовано то, что нужно. Может еще что-нибудь понадобиться -
     посмотрим.
*** TODO Version 2.0
**** TODO [#B] (?) NXList - linked list
**** TODO [#B] (?) NXIndex 
     NXIndex index symbols of text information (docs, sources, config files)
     for fast search.
*** Полезное
    1. [[http://www.davidhamrick.com/2011/10/10/handling-filesystem-events-with-gcd.html][Handling Filesystem Events with GCD]]

      int fildes = open("/path/to/config.plist", O_RDONLY);
       
       dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
       dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE,fildes,
                                                         DISPATCH_VNODE_DELETE | DISPATCH_VNODE_WRITE | 
                                                         DISPATCH_VNODE_EXTEND | DISPATCH_VNODE_ATTRIB | 
                                                         DISPATCH_VNODE_LINK | DISPATCH_VNODE_RENAME | 
                                                         DISPATCH_VNODE_REVOKE, queue);
       dispatch_source_set_event_handler(source, ^
       {
               //Reload the config file
       });
       dispatch_source_set_cancel_handler(source, ^
       {
               //Handle the cancel
       });
       dispatch_resume(source);
       
       ...
       
       // sometime later
       dispatch_source_cancel(source);

    2. [[http://repo.or.cz/w/eleutheria.git/tree/master:/kqueue][Examples of kqueue]]


** TODO NXSystem
   OS-dependant calls. Abstraction layer to hide OS specifics.
*** DONE [#A] NXSystemInfo
**** DONE processor (type, speed), memory size, OS (type, bitness);
*** DONE [#A] NXFileSystem
**** DONE FS size
**** DONE FS mount point
     [[MediaManager mountedVolumeForPath:] objectForKey:@"MountPoint"];
**** DONE FS type
     [[MediaManager filesystemTypeAtPath:] objectForKey:@"FileSystemType"];
*** DONE [#A] NXFileSystemMonitor
**** DONE Под Linux нужно переделать
***** DONE Преобразовать IN_CREATE и IN_DELETE в 'Write'
***** DONE IN_ATTRIB - Attributes
***** DONE IN_MOVE_SELF, IN_MOVED_FROM, IN_MOVED_TO
      Перемещение и переименование.
***** DONE IN_DELETE_SELF - Delete+Write
**** DONE Паковать множество изменений по каталогу
     Критерий паковки: путь.
     {
       wd = ("Write", "Delete"|"Create"|"MovedFrom"|"MovedTo");
     }
     Если элемента нет - добавляем, если есть:
     - проверяем операцию 1, если операции одинаковые = один елемент (даже
       если одина Delete, а вторая Create)
     - если операция 2 существующей операции "MovedFrom", а текущий "MovedTo" =
       заменить операцию 1 на "Rename".
     После этого в цикле отправляем notifications.
**** DONE Упаковка Rename + Attributes
     Приложение должно сначала получать Rename, а потом Attributes на новый
     файл. Сейчас Rename и Attributes пакуются и остается только Attributes:
     Workspace не меняет выделенного файла - выделенным остается
     несуществующий файл.
     Паковать события нужно так, чтобы события, которые относяться к одному
     файлу в каталоге были отдельными событиями. Например: удаление
     множества файлов пакуются в одно событие; создание 10 файлов и
     изменение аттрибутов одного из них должны паковаться в 1 событие.
*** DONE [#A] NXMediaManager
**** DONE [#A] NXUDisksAdaptor (интеграция с UDisks)
***** DONE Реализовать loop-монтирование: ISO, IMG
      все loop:
      - Drive="/"
      - HintSystem=true
      - HintAuto=false
      loop drive:
      - есть интерфейс org.freedesktop.UDisks2.Loop
      - нет org.freedesktop.UDisks2.Partition
      loop partition:
      - есть org.freedesktop.UDisks2.Partition с:
        Table="/org/freedesktop/UDisks2/block_devices/loop#"
***** DONE Разобраться с set/get типов glib в/из properties объектов
      Нужно проверить, чтобы единообразно типы сохранялись при создании
      NSDictionary и единообразно извлекались. Плюс удалялсь/заменялись
      символы, от которых у NSString едет крыша (кавычки, скобки и т.д.).

      Особенно нужно уделить внимание массивам: похоже они могут быть разными.
      Например: Symlinks, Configuration, MountPoints.
***** DONE Сделать eject/unmount асинхронным с уведомлением об операции
****** Размышления
      Асинхронный метод: unmountRemovableVolumeAtPath.
      Начало: 
      - monitor_on_object_added()
      - _addUDisksObject:ud_object andNotify:YES
      - postNotification:NXMediaOperationDidStart
      Окончание:
      - monitor_on_interface_proxy_signal
      - _updateJob:objects:signal:parameters:
      - postNotification:NXMediaOperationDidEnd

      Похоже нужно переписать общий принцип mount/unmount/eject.
      Переписать таким образом, чтобы размонтирование не приводило к
      зависанию всего приложения (в случае если в процессе размонтирования
      сбрасывается кэш записи). Это касается и синхронного (возращает
      смонтированный путь) и асинхронного режима.
      [NX*Adaptor unmountAndEjectDeviceAtPath:]
      [NX*Drive unmountVolumesAndDetach] может вызываться:
      - Disk->Eject - асинхронно;
      - Quit - синхронно, приложение не должно завершать работу,
        пока не размонтированы все тома и не остановлены устройства.
      - [NX*Drive unmountVolumes:], [NX*Volume unmount:] может вызываться:
        - Disk->Unmount - асинхронно;
        - [NXDrive unmountVolumesAndDetach] - смотря откуда вызвано.

      В Workspace это можно сделать так:
+     1. Disk->Unmount - всегда *асинхронная* операция, с появлением задачи в Processes.
+     2. Disk->Check Disks - [NX*Adaptor checkForRemovableMedia] *асинхронно* вызывает
         [NX*Drive mountVolumes], задачи появляются/исчезают по мере выполнения.
+     3. Disk->Eject [NX*Adaptor unmountAndEjectDeviceAtPath:] -
         вызывается *асинхронно*, отправляет OperationDidStart, в
         Processes-Background появляется задача(и) "Ejecting...",
         "Unmounting...". По завершению (OperationDidEnd) этих задач
         появляется панель с предложением отключить диск.
+     4. Quit -> [NX*Adaptor ejectAllRemovables] - *асинхронно*, с
         появлением тех же задач в Processes. Выход приложения откладывается
         до завершения всех задач в Processes-Background. Панель с
         уведомлением о существующих задачах появляется только если есть
         файловые операции).
+     5. [NX*Adaptor mountNewRemovableMedia] - *синхронно*, с возрвратом точек
         монтирования. Задачи могут появляться, могут не появляться поскольку
         runloop стоит в ожидании возврата из этого метода, поэтому GUI не
         обновляется, уведомления не обрабатываются и т.д. Хотя операции
         монтирования, как правило, быстрые - разве что, будет запущен
         процесс проверки целостности ФС (но, насколько я знаю, по-умолчанию
         этого не проиходит).
****** DONE Сделать [NX*Drive unmountVolumesAndDetach] асинхронным
       Вызывается:
       [NX*Adaptor unmountAndEjectDeviceAtPath:] - Workspace->Disk->Eject
       [NX*Adaptor ejectAllRemovables] - Workspace->Quit
***** DONE Панель выскакивает раньше чем завершается unmount Job!
***** DONE Сделать сообщения о неудачных операция более человечными
      Нужно передавать GError* функциям udisks (например:
      udisks_filesystem_call_unmount_) и ловить его в callback как user_data.
      Похоже внутри GError есть: error->domain, error->code...
      Нужно посмотреть, что там еще есть.
****** DONE При eject SD alert panel не выпрыгивает
****** DONE oldMountPoint не читается
***** DONE Не выбрасывать alert panel при успешном eject оптических дисков
***** DONE CD не монтируются автоматически
      Нужно реализовать добавление интерфейсов к существующим объектам.

      В NXUDisksVolume в методе isFilesystem убрал проверку на наличие
      интерфейса Filesystem. Зачем я ее добавлял - ХЗ. Пока - так.
***** DONE Проверить разные файловые системы (NTFS, FAT, VFAT, UDF, ISO9660, EXT*)
      - NTFS, FAT, VFAT, UDF, ISO9660 = OK.
      - UFS: монтирование оригинальных CD с OPENSTEP: в CentOS 7 нет поддержки UFS
        и ufstype=nextstep-cd. Решается сборкой модуля UFS.
      - EXT*: монтируется с правами пользователя, с которыми была
        создана. Нужны опции, которые будут разрешать чтение/запись
        пользователю, который смонтировал устройство.
***** DONE Методы NSWorkspace
      Убрать методы, которые должны быть в NSWorkspace. Если нужны такие
      действия - переименовать используя терминологию Drive/Volume (вместо
      Disk/Media).
***** DONE Аттрибуты объетов (интерфейсов) UDisks
      По-хорошему нужно не переименовывать properties объектов
      (интерфейсов), а просто конвертировать в NSDictionary.
      Тут может пригодиться идея с NXDisk и NXVolume. Нужно думать.
      
      Сделано: NXUDisksDrive, NXUDisksVolume. Код стал чище и понятнее, но аттрибуты
      храняться внутри объектов. Для отладки сделал внутри каждого объекта запись 
      аттрибутов в виде NSDictionary в файл.
***** DONE Переписать
***** DONE Добавление, удаление устройств
***** DONE Получение информации о дисках и файловых системах
***** DONE Отправка NSNotfication в ответ на события UDisks
***** DONE fileSystemTypeAtPath:
***** DONE mountedRemovableMedia:
***** DONE Действия
****** DONE PolicyKit
       Для монтирования нужно разобраться с PolicyKit: нужно, чтобы не спрашивал 
       пароль root для автомонтирования. Или подумать о том, как запрашивать/передавать 
       пароль. Вот:
       PolicyKit: /usr/share/polkit-1/actions/org.freedesktop.udisks2.policy:

       <action id="org.freedesktop.udisks2.filesystem-mount-other-seat">
       <action id="org.freedesktop.udisks2.power-off-drive-other-seat">
       <action id="org.freedesktop.udisks2.eject-media-other-seat">
         <defaults>
           <allow_any>yes</allow_any> <--------------------- CHANGE!!!
           <allow_inactive>auth_admin</allow_inactive>
           <allow_active>auth_admin_keep</allow_active>
         </defaults>
       </action>
****** DONE Mount повторно: checkForRemovableMedia/mountNewRemovableMedia
******* DONE mountNewRemovableMedia - синхронно
******* DONE checkForRemovableMedia - асинхронно
****** DONE Mount автоматически
       Workspace должен делать это при старте (вызывать checkForRemovableMedia).
       NXUDisksAdaptor должен это делать при добавлении устройств с файловыми системами.
****** DONE Unmount
****** DONE Eject/PowerOff
       Последовательность:
       1. unmountAndEjectDriveAtPath: (drivesToEject updated)
       2. unmountVolume:andWait:
       3. _updateMountPoint:forObjectPath:
       4. ejectIfNeededDrive:
          1. ejectDrive:andWait:
          2. powerOffDrive:andWait:
       5. _removeUDisksObjectWithPath: (drivesToEject updated)
****** DONE Unsafe detach
       UDisks видит, что флешка вытащена и запускает Job "cleanup".
       Удаляет устройства из /dev без размонтирования.
       Нужно: ловить удаление разделов и проверять параметр "MountPoint". Если
       раздел смонтирован отправлять notification.
****** DONE Ошибки при операциях
**** TODO [#C] NXHALAdaptor
***** TODO Привести в соответствие с NXUDisksAdaptor
      Имена notification, имена параметров дисков и томов (файловых систем).
***** TODO Проверить компиляцию и работу на FreeBSD
*** TODO [#B] NXScreen (via XRandR extension)
**** DONE Список мониторов
**** DONE Установка разрешения и refresh rate
***** DONE Установка layout по-умолчанию
      [NXScreen resetLayoutAndArrange:(BOOL)arrange].
      Если arrange=YES, мониторы выстраиваются горизонтально. 
      Если NO - накладываются (у всех CRTC origin: 0,0).
***** DONE Preferred Mode
      output_info->npreferred - количество первых в списке препочитаемых
      разрешений. Нужно выбирать максимальное разрешение.      
**** DONE Делать монитору ON/OFF
     С OFF просто: ставим разрешение 0x0 и делаем XRRSetScreenSize.
     С ON сложнее: нужно сделать назначение для Output соответствующего CRTC
     (во время выключения  монитора связь Output-CRTC рвется).
**** DONE Чтение properties
     - EDID - будем использовать как уникальный идентификатор.
     - backlight - backlight, BACKLIGHT (0-7)
     - аудио через HDMI? - audio (force-dvi, off, auto, on)
     - scaling mode - (None, Full, Center, Full aspect)
**** DONE XRRSetCrtcGamma
***** DONE Set Gamma Correction
***** DONE FadeIn/FadeOut
***** DONE Get Gamma Correction
**** DONE Концепция Main Display
     Позволит модифицировать нужные приложения для того, чтобы:
     - WindowMaker размещал на нем miniwindows, Dock;
     - GNUstep размещал application menu;
     - размещать окна на этом мониторе по-умолчанию.
     Для проверки можно использовать Applications/Login.
     Нужно:
     1. Перепроверить первоначальное получение корректной информации (особенно
        isActive, isMain).
     2. Перепроверить поведение при shared/alloc-init.
**** DONE Проверить количество rate для одного resolution
     То, что показывает NXDisplay и xrandr не совпадает.
**** DONE NXDisplay: менять разрешение только если отличается
**** DONE Переписать setResolution
     Вызов [NXDisplay setResolution:origin:] напрямую не меняет размер
     NXScreen.
     Однако, изменение разрешения монитора (NXDisplay) менят размер экрана
     или/относительное разположение мониторов всегда. Поэтому должны быть
     переписаны:
     - [NXScreen applyDisplayLayout:] - выделить отдельно изменение размера
       NXScreen.
     - [NSDisplay setResolution:origin:] - возможно стоит разделить на 2
       метода: один - меняет описание layout и вызывает [NXScreen apply...],
       другой - только меняет разрешение монитора (вызывается только 
       [NXScreen apply...]).
    Переписал следующим образом:
    - [NSDisplay setResolution:origin:] устанавливает разрешение и позицию
      дисплея безусловно - layout не меняет (не вызывает метод NXScreen).
    - добавил метод [NXScreen setDisplay;resolution:origin:], который как раз
      меняет разрешение только после проверки и изменения layout дисплеев.
**** DONE Displays.config keys in NXScreen.h
     Плюс, добавил отдельный метод для проверки корректности layout.
**** DONE Проверить работает ли изменение разрешения при увеличении экрана
**** DONE Проверять поддерживает ли дисплей Gamma
     Непонятно, как это сделать. Пока поддержка Gamma определяется по:
     - наличию CRTC;
     - возможности получения размер gamma (XRRGetCrtcGammaSize).
**** DONE Использование XRRScreenResources
     Нужно определить когда обязательно нужно обновлять.
      NXDisplay:
      - setResolution:origin:
      - setMain:
      NXScreen:
      - applyDisplayLayout:
      - setDisplayMain:

      Calling of the methods above (or changing screen configiguration via
      'xrandr' utility) results in emitting NXScreenDidChangeNotification by
      WorkspaceManager or Login (or whatever app which has X11 event loop and
      listens to RandR events).
      So update of screen configuration is a responsibility of application
      which uses NXSystem. 
      NXSystem should update XRRScreenConfiguration only in case of changing
      main (primary) display - XRRSetOutputPrimary doesn't generate
      notification (event). It's [NXScreen setMainDisplay:] and 
      [NXDisplay setMain:] methods.

      Заодно пофиксил использование "static id systemScreen" - перенес в
      самый верх - перестал вызываться -init при каждом вызове +sharedScreen.
**** DONE Применение конфигурации display layout
     Конфигурация изменяется при помощи Preferences.app->Display.
***** DONE Default layout: учитывать состояние LID
      Если LID->closed делать монитор неактивным.
      Релизовано [NXPower isLidClosed] и использовано в -applyDisplayLayout.
***** DONE Конфигурация по-умолчанию при запуске Xorg/Login
      Login устанавливает defaultLayout всегда.
***** DONE Сохранять в layout EDID (уникальный идентификатор)
***** DONE Проверка EDID монитора перед применением layout
**** DONE NXDisplay: определять lid closed/opened
     Основные вопросы:
     1. как узнать о статусе LID?
        -> /proc/acpi/button/lid/LID/state
     2. как узнать о смене статуса LID (откр./закр.)?
        -> чтение /var/run/acpid.socket
     3. как узнать какой монитор обладает LID (какой монитор вкл./выкл.)?
        -> все, имя output которых содержит LVDS и eDP.
     5. как управлять/перехыватывать реакцию системы на смену статуса LID?
        -> запретить suspend если подключен внешний монитор:
           LidSwitchIgnoreInhibited=no > /etc/systemd/logind.conf
        -> настроить 'acpid' - /etc/acpi/(events|actions)

     Пока запретил засыпать ноутбуку если подключен внешний монитор через:
     LidSwitchIgnoreInhibited=no, в /etc/systemd/logind.conf
     Ловить события можно:
     - через чтение сокета: /var/run/acpid.socket;
     - отдать на откуп 'acpid' и сконфигурировать поведение через
       /etc/acpi/(events|actions);
     - подключившись к dbus и ловя сообщения от logind - не ловится!
     - нужно ловить события от UPower - сообщает о lid close/open; также
       хранит и сообщает информацию о батарее и состоянии подключения к 
       розетке; наверное стоит вынести эту функциональность в NXPower.

      Релизовано [NXPower isLidClosed] и использовано в -applyDisplayLayout.
**** DONE Округление значений гаммы до второго знака после запятой
     В основном вся магия находится в [NXDisplay _getGamma]. При вычислении
     гаммы используется магическое число '0.5'. Не до конца понимаю почему,
     но работает. Может потом нужно будет разобраться до конца.
**** NXDisplay: Resolution, Origin и frame
     Кажется, что изменения должны быть концептульнее. Сейчас frame напрямую
     связан с Resolution и Origin: изменение Resolution обновляет frame если
     Resolution width и height больше 0.
     
     На самом деле это не имеет смысла поскольку в случае изменений генерится
     событие RandR, которое приводит к пересозданию NXDisplay. Для выключенных
     мониторов (был вызван -deactivate) это приводит к значениям 0 для всех
     значений frame.origin.
     
     frame - сохраненная информация о разрешении и положении.
     При запросе разрешения (NSDictionary - {Size={}, Rate={}}) по
     сохраненным значения, которые входят в 'frame' находится resolution из
     списка поддерживаемых монитором. Таким образом, основной ivar, которая
     характеризует монитор - 'frame'. Вот на нее и стот обратить пристальное
     внимание.
     
     Заменять Resolution = {} и Origin = {} на Frame смысла нет. Наоборот,
     Resolution это копия из списка поддерживаемых разрешений, а Origin
     устанавливается при вызове -setResolution:origin:.
     
     При возникновении события RandR (изменение разрешения, расположения,
     activate, deactivate) нужно:
      1. Перечитать XRRScreenResoutrces - уже
      2. Пересоздать список NXDisplay - уже
      3. Переразместить дисплеи относительно друг друга (изменить layout)
         [NXScreen arrangeDisplaysHorizontally]
      4. Применить измененнный layout - [NXScreen applyDisplayLayout:newLayout]
      5. ? Записать layout в пользовательский конфиг
         
     _Активирование/деактивирование_:
     
     СЕЙЧАС:
      - [NXDisplay deactivate];
      - [NXDisplay setResolution:origin:];
        
      - генерируется событие XRRScreenChangeNotify;
      - [Preferences screenDidChange:];
      - [NXScreen randrUpdateScreenResources];
        
     НУЖНО, deactivate:
      + [NXScreen deactivateDisplay:(NXDisplay*)];
        + сохраняет текущую 'frame' в 'hiddenFrame';
        + обнуляет значения 'frame'.
      - (NSArray*)[NXScreen arrangeDisplays];
        - пересчитывает 'frame.origin' активных дисплеев со сдвигом влево;
        - строит новый layout на основании 'frame' дисплеев;
      + [NXScreen applyDisplayLayout:(NSArray*)];
        
      + генерируются события XRRScreenChangeNotify;
      + [Preferences screenDidChange:] (будет в Workspace);
      + [NXScreen randrUpdateScreenResources];
        + при обновлении переносит hiddenFrame для неактивных дисплеев.
          
     _Концепция_
     
     Концептуально получается, что любые изменения в характеристиках
     дисплеев, которые приводят (или могут привести) к изменению layout
     должны выполняться под управлением (реализовано в) NXScreen.
     Любые вызовы методов NXDisplay: activate, deactivate,
     setResolution:origin: приводят к кривому layout. Например:
      - activate - завершается неуспешно, потому, что RandR screen не может
        вместить новый дисплей (за исключением случая, когда origin={0,0} и
        активируемый дисплей меньше уже активного);
      - deactivate - не обновляет размер RandR screen;
      - setResolution:origin: - завершается неуспешно по той же причине, что и
        activate.
        
     	_NXScreenLayout_
        
        Наверное нужнен класс, которы позволит удобно манипулировать содрежимым
        layout. Очевидно, нужно будет:
        - находить аттрибуты дисплея;
        - удобно менять Origin, Resolution;
        - хранить предыдущие значения Origin и Resolution;
**** DONE NXScreen: arrangeDisplays
     DLD - display layout description - NSDictionary
     NXD - NXDisplay live object that represents monitor
***** DONE Case 1: деактивация 
      Prepare request:
       - [NXDisplay setHiddenFrame:[NXDisplay frame]]
       - [NXDisplay setFrame:{0,0,0,0}]

      Result after preparation:
       Active = "YES", 'frame.size' = {0,0}, 'hiddenFrame.size' != {0,0}

      Display _deactivation_ requested:
       - Active will be set to "NO" by applyLayout:;
       - 'hiddenFrame' will restored by randrUpdateScreenResources;
       - arrangeDisplays:
         - adjust other active displays' origins if needed.
           [DLD]
***** DONE Case 2: активация
      Prepare request:
       - [NXDisplay setFrame:[NXDisplay hiddenFrame]]

      Result after preparation:
       Active = "NO", 'frame.size' != {0,0}

      Display _activation_ requested:
       - change Active to "YES";
       - set resolution and origin;
       - adjust other active displays' origins if needed.
***** DONE Case 3: смена разрешения (frame.size)
      Active = "YES", "frame.size" != {0,0} and differs from "Resolution"
***** DONE Case 4: смена позиции (frame.origin)
      Active = "YES", "frame.origin" and differs from "Origin"
**** DONE Запись и чтение конфигов с layout'ами
***** DONE Кто и в каких случаях?
      Нужно определить кто и в каких случаях должен инициировать сохранение
      конфига. 
      Пока видятся такие варианты:
      1. Изменение настроек в Preferences - записывает Preferences
      2. Изменения извне (xrandr): 
         Workspace -> NXScreenDidUpdateNotification
      3. Подключение/отключение мониторов:
         Workspace -> NXScreenDidUpdateNotification

      Единственное пользовательское приложение, которое регистрирует все 3
      нижеописанных сценария - Workspace. Может пусть и пишет?
      Если будет писать Workspace, Preferences только инициирует изменения и
      регистрирует через получение NXScreenDidChangeNotification.

      DONE:
      1. Изменения в конфигурации дисплеев, которые генерируют
         XRRScreenChangeNotify (xrandr, Prefernces, plag'n'play)
         - пишет Workspace.
      2. Изменения, которые не генерирует Notify (backlight, brightness,
         contrast):
         - пишет каждое приложение, которое вносит измнение в настроку
           дисплеев.

****** DONE Запись:
       [NXScreen saveCurrentDisplayLayout];
****** DONE Чтение:
       [NScreen applySavedDisplayLayout];
***** DONE Класть конфиги в ~/Library/Peferences/.NextSpace -> Workspace
      Новые методы NXScreen это уже делают.
      Нужно проверить чтобы Login, Workspace и Preferences пользовались
      этими методами.
***** DONE Нужно как-то опеределять layout'ы
      DONE: генерируется файл с именем формата: 
            Display-<сумма хешей ID дисплеев>.config
      TODO: это не правильно - сумма хешей может привести к коллизии (сумма
      хешей разного сочетания мониторов может совпадать). Поэтому нужно
      сохранять отдельный файл для каждого монитора + файл с layout.
      Сделал отдельную задачу - нужно будет реализовать как-нибудь.

      Сейчас нет истории использования ноутбука. Например, если ноутбук был
      подключен к монитору (layout1), а затем был отключен и подключен к
      телевизору (layout2) layout1 будет перзатерт layout2. После возвврата
      ноутбука к монитору - будет сгенерен dafault layout.

      Нужно чтобы как-то запоминались такие случаи использования. Варианты:
      1. Добавлять к имени конфига цифру (Displays-1, Displays-2). При
         подключении к внешнему дисплею проходится по сохраненным конфигам и
         проверять не наш ли это случай.
      2. Генерировать hash и добавлять к имени файла. При подключении
         генерировать default layout, считать hash подключенных мониторов и
         сравнивать с суффиксом в имени файла. Правда просто чтение конфига
         (например, при старте) тоже будет происходить через генерацию hash'а.

      Дополнительный вариант на подумать: при подключении/отключении всегда
      остается один неизменный дисплей - внутренний. Но между отключением от
      предыдущего дисплея и подключением к новому ноутбук находится в
      "чистом" состоянии - с единственным дисплеем - внутренним. Поэтому, тут
      может быть только один вариант искать сохранненый и применять или
      переходить к default layout с автоматическим размещением.

      Таким образом, в случае с монитором и телевизором должно быть как
      минимум 3 конфига: только встроенный дисплей, встроенный+монитор,
      встроенный+телевизор.

**** TODO События (изменение параметров, подключени/отключение мониторов)
***** Мысль №1
     События ловятся через обработку событий X11 (X events). Ловить нужно
     XRRScreenChangeNotifyEvent. Поскольку в run loop сложно встроить
     обработку событий X11 (блокирует или замедляет работу приложений),
     логично обрабатывать его в window manager. В данном случае это
     Workspace (вернее часть Workspace, которая WindowMaker). Это уже и так
     делается в event.c, только это приводит к выходу из Workspace.
     Нужно:
      - из WindowMaker не выходить, а обновить внутренние переменные WM;
      - отправить notification для заинтересованных
        (NXScreenDidChangeNotification);
      - обновить параметры дисплеев внутри NXScreen.
        
     По большому счету ловить события нужно там, где обрабатываются события
     X-сервера (а это window manager). Но, с другой стороны, Login должен
     тоже реагировать на события подключния/отключения монитора.

     Как быть?
***** Мысль №2:
     - для того, чтобы Login реагировал на изменение конфигурации экрана,
       нужно, чтобы сам Login ловил события X11 и обрабатывал случай с
       событием RRScreenChangeNotify (XRRSelectInput(dpy, root_win,
       RRScreenChangeNotifyMask));
     - после того, как Login переходит в неактивное состояние (пользователь
       делает logon):
       - событие RRScreenChangeNotify начинает обрабатывать WorkspaceManager
         (внутри WindowMaker EventLoop());
       - Login перестает обрабатывать это событие: XRRSelectInput(dpy,win,0)(?);
     - после того, как пользователь сделал logout, Login:
       - перечитывает информацию о NXScreen;
       - правильно размещает свое окно;
       - начинает ловить RRScreenChangeNotify (XRRSelectInput);
       - показывает окно.
     Итого, главный принцип событие XRRScreenChangeNotify в единицу времени
     должно ловить одно приложение (Login или WorkspaceManager). Каждое
     приложение это делает самостоятельно и шлет NSNotification через
     NXDistributedNotificationCenter.
***** DONE Workspace: размещать Dock и IconYard на mainDisplay
****** DONE При изменении размеров размеров во время работы
       Сделал в Workspace+WindowMaker.m (XWUpdateScreenInfo()).
****** При старте Workspace (WindowMaker)
       Частично сделано. Но Dock сначала появляется справа, и только потом,
       перемещеается на primary display. Переместил в Workspace.
***** DONE Login: перемещать окно на mainDisplay по центру
****** DONE При старте
****** После старта (нужен EeventLoop), в активном режиме
       Добавил задачу к Login. Помечаю здесь как выполненное.
***** TODO Open/close laptop lid
      Задача перенесена в NXPower и реализована.
      Теперь нужно заставить это работать в Workspace.
***** TODO Подключение монитора на лету
      Q:Как ловить подключение нового монитора?
      A:ХЗ - XRRScrenChangeNotify не генерируется. Событие udev тоже не
      генерируется, пока не дернуть драйвер (например, через 'xrandr').
      Генерируется, просто нужно выждать некоторое время (секунд 5) после
      отключения монитора перед следующим подключением.

      Q:Как поступать при подключении монитора к ноутбуку?
      A:На момент подключения, могут быть такие ситуации:
        1. Ноутбук закрыт, внутренний экран активен, основной.
           Реакция: активировать внешний, сделать его активным и основным;
           внутренний деактивировать; fadeOut/fadeIn только для внешнего.
        2. Ноутбук открыт, внутренний экран активен, основной.
           Реакция: активировать внешний, поставить его справа от
           внутреннего; fadeOut/fadeIn только для внешнего монитора.

***** TODO Отключение монитора на лету
      Q:Как ловить отключение нового монитора?
      A:На отключение генерируется XRRScrenChangeNotify.
      	Подключенный монитор находится в неактивном состоянии.
      	Конфигурация экрана XRandR перечитывается.

      Q:Как поступать при отключении монитора?
      A:На момент подключения, могут быть такие ситуации:
        1. Ноутбук закрыт, внутренний экран неактивен.
           Реакция: заснуть.
        2. Ноутбук открыт, внутренний экран активен, основной.
           Реакция: перечитать конфигурацию, пересчитать
           параметры экрана, передвинуть внутренний экран если он был справа.

**** TODO Проверить работу сохраненных .NextSpace/Display-xxxx.config
     Генерируется файл с именем формата: 
     	Display-<сумма хешей ID дисплеев>.config
     Нужно проверить как это работает после этого как разберусь с 
     событиями.
**** TODO Иногда display включается с gammaBrightness=0
     Нужно найти такой кейс и решить этот вопрос.
     Это дастаточно важный момент, поскольку можно оказаться с темным экраном
     и без возможности изменить яркость (даже в консоли) = перезагрузка.

     Кажется я понял в чем дело: это следствие деактивации монитора с
     эффектом затухания. Происходит это так:
     1. Запоминается текущее значение gammaBrightness.
     2. Вызывается fadeToBlack:
     3. Выключается монитор (устанвливется разрешение 0x0).
     4. Вызывается setGammaBrightness.
     На шаге №4 должно устанавливаться (возвращаться) исходное значение для
     выключенного монитора. Но проблема в том, что это значение не
     устанавливается! Поэтому для таких случаев значение gammaBrightness
     должно запоминатся в layout или где-то еще, откуда оно может быть
     считано перед активацией монитора.
**** TODO Fade In/Fade Out
***** TODO Использовать в нужных местах
      Нужно пройтись по коду и проверить/добавить/убрать где было бы
      целесообразно использовать этот эффект. Сейчас он где-то в одном месте
      включен, но где - нужно найти.
***** TODO fadIn/fadeOut по времени
**** TODO NXDisplay: rotation & reflection
**** Сохранение конфигов для каждого монитора отдельно
      Генерируется файл с именем формата: 
            Display-<сумма хешей ID дисплеев>.config
      Это не правильно - сумма хешей может привести к коллизии (сумма
      хешей разного сочетания мониторов может совпадать). Поэтому нужно
      сохранять отдельный файл для каждого монитора + файл с layout.
**** Управление конфигурациями и взаимодествием видеоадаптеров
     На текущий момент NVIDIA Optimus не работает заявленным способом.
     Единственный работающий вариант: Bumblebee (запуск отдельного X-сервера с
     отображением на текущий под управлением Intel).
     Поэтому эта задача сводится к правильно установленному и настроенному
     Bumblebee, чтобы легко можно было бы использовать утилиту 'optirun' или
     'primusrun'.
*** TODO [#B] NXPower
**** DONE State of the LID (open/closed)
***** DONE Методы получения статус и наличие Lid
***** DONE Событие открытия/закрытия крышки
      DONE! Отправляется notification в NSNotificationCenter.
      Приложение, которое хочет получать такой notification, должно запустить
      процесс мониторинга через вызов [NXPower startEventsMonitoring].
**** TODO Load battery information
**** TODO Power state (battery/AC)
***** TODO Return current power state
***** TODO Notify about power state changes
**** TODO Power profile (tuned?)
**** TODO Shutdown/Restart
**** TODO Hibernate/Sleep
*** TODO [#B] NXKeyboard - type, input languages, shortcuts, repeat rate
**** TODO Keyboard type (Xorg keyboard types)
**** TODO Input languages (Xkb layouts)
**** TODO Repeate rate (Xorg)
**** TODO Control, Alternate, Command mapping (GNUstep)
     Из Terminal:
     /*
     Thanks to different keyboard layouts and dumb default key handling
     in GNUstep, this is a bit complex. There seem to be two main cases:
     
     a. GNUstep has been correctly configured. Command is really command,
     alternate is really alternate, and is used as meta. AltGr isn't
     anything at all. No special options necessary.
     
     b. GNUstep is using the default settings. Left alt is command, right
     alt (which might be AltGr) is alternate. Users seem to actually want
     left alt to be meta, and, if right alt is AltGr, right alt not to be
     meta. Thus, when command-as-meta option is active, we intercept
     command presses and treat them as meta, and we ignore alternate.
     */
     Проще всего это сделать черезе defaults write NSGlobalDomain.
*** TODO [#B] NXMouse - type, acceleration, buttons mapping, pointer
    Посмотреть в WindowMaker.
*** TODO [#C] NXSound - volume/bass/treble/balance, device information
*** TODO [#C] NXNetwork - hostname, interfaces, routes, user initiated up/down, WiFi
*** [?] NXDeviceManager
    Register added/removed system devices (storage, monitor, mouse, keyboard,
    bluetooth).
    Большинство вложенных классов нужны для конфигурирования в
    Preferences.app(Configure.app?). Поэтому, перед началом имплементации этих
    классов нужно посмотреть в задачи по Preferences.app(Configure.app?).
**** Инфо
     _Источники информации_:
     - udev/UDisks/UPower/NetworkManager (Linux)
     - devd (FreeBSD)
     - hal (FreeBSD, Linux)
*** [?] NXAuth - user authentification, user/groups management


* Applications

** Приложения, которые нужны мне
 1. База:
    + Login
    + Workspace Manager (file/device/application/window manager)
    + Preferences: time, calendar, keyboard layout, power, login, fonts,
      languages. Все расширенные настройки нужно сделать отдельными
      приложениями в отдельном каталоге. Интерфейс ala "System
      Preferences" можно реализовать прямо в FileViewer'e.
    + Terminal
 2. Данные
    + Edit (full-featured RTF/RTFD application): styles, lists, tables, images
    + Хранение заметок, мыслей, дел: RTF, ссылки, TODO-list, контакты
      (посмотреть на NoteBook.app for NeXTSTEP (Millennium Software),
      OmniFocus).
    + Dictionary - русско-английский, англо-русский (нужно воскресить,
      когда-то написанный Dictionary.app под WindowMaker)
    + Digital Librarian: доступ к документации в системе - help
      приложений, документация разработчика (RTFD, HTML), man pages, PS,
      PDF. Сканирование документов нужно сделать только отдельного(ных)
      каталогов (например, /Library/Documentation,
      /Developer/Documentation, ~/Documentation). Это делает приложение
      предсказуемым (не хочешь, чтобы что-то сканировалось - убери
      документ в другой каталог) и заставляет пользователя навести порядок
      в хранении документов.
 3. Сеть
    + Доступ по FTP/SFTP/CIFS, возможно из Workspace Manager.
    + Торрент-клиент (портировать Transmission на GNUstep?).
    + Почтовый клиент - Thunderbird.
    + Браузер - Firefox.
    + Читалка RSS - Inoreader в Firefox.
 4. Медиа
    + Музыкальный плеер (MP3, AAC, FLAC)
    + Видео плеер типа NEXTIME (MKV, AVI, MPEG, MOV). Может сделать на
      базе Mplayer или VLC?
    + Просмотрщик картинок с простыми инструментами преобразования (crop,
      rotate...)


** 0. Application implemented Contents Inspectors
*** TODO Готовность Frameworks->NXFoundation->NXBundle
**** TODO Поиск внешних инспекторов
**** TODO Доступ к мета-информации (bundle.registry)
*** TODO TextEdit
*** TODO Preview
*** TODO Player
   - Player.app: Sound - codec, bitrate, sampling, duration, album,
     artist, song, мини плейер.


** 1. Login
*** TODO Версия 1.0
**** DONE Вход/выход без неожиданностей (core dumps)
**** DONE Взаимодействие с Workspace Manager - Power Off
**** TODO Корректная работа с многомониторными конфигурациями
***** DONE Устанавливать display layout по-умолчанию
***** DONE Устанавливать сохраненный display layout
      /usr/NextSpace/Prefrences/Displays.config
***** DONE Расположение окна по центру main display
      Нужно проверять каждый раз при завершении пользовальской сессии,
      поскольку display layout мог измениться.
***** TODO Ловить события XRandR: нужен свой EventLoop
***** TODO Ловить подключение/отключение мониторов (как?)
***** TODO Обновлять информацию о мониторах после завершения сессии
**** TODO Взаимодействие с Workspace Manager - Reboot
**** DONE Shrink окна при старте пользовательской сессии
     Реализовал shrinkPanel и shakePanel с помощью функций X11.
     Через GNUstep получается медленно и с непредсказуемой скоростью.
**** TODO Простой скринсейвер
     Что-то периодически перемещающееся по экрану или просто текст.
     NXSystem/NXPower?
*** TODO Версия 2.0
**** TODO Выдача панели при некорректном завершении пользовательской сессии
**** TODO Перезапуск пользовательской сессии при её некорректном завершении
*** TODO Когда-нибудь:
**** TODO Взаимодействие с Workspace Manager - Hibernate
     Зависит от реализации hibernate в OC. В FreeBSD, насколько мне
     известно, с этим все плохо.
**** TODO Fade-in/Fade-out экрана при переходах
**** TODO Переключение между пользователькими сессиями


** 2. Workspace Manager
*** TODO Версия 1.0 [19/24]
    :PROPERTIES:
    :COOKIE_DATA: todo reccursive
    :END:
**** TODO *Ошибки/падения/неправильное поведение* [41/45]
***** TODO Выход из Workspace == segault
      Сюда буду вписывать разные случаи непонятного, некритичного segfault:
      - [X] при открытом окне Processes (нужно делать close и release окна).
      - [ ] если открыты одновременно 'Processes' и 'Inspector', причем если
        'Inspector' был открыт первым (мистика какая-то...).
***** TODO Иногда повисает процесс копирования/перемещения
***** TODO Dock перестает принимать иконки по DnD
      Это связано с Xinerama - нужно будет этим отдельно заняться.
***** TODO Не отображается 'Tools Inspector' для .gorm
      Возможно это из-за того, что .gorm это каталог.
***** DONE Кажется не работет Duplicate
      Причем похоже с каталогами.
      Генерит: Problem posting notification: <NSException: 0x2e525f0>
      NAME:NSInvalidArgumentException REASON:Tried to add nil value for key
      'Files' to dictionary...
      Проблема была в новом коде передачи '-Files' через 'env'.
***** DONE Kill в Processes
      Приложение не исчезает из списка запущенных.
***** DONE При копировании каталога с подкаталогами
      ...копируется только первый каталог.
***** DONE При ошибке панель 'Processes' не появляется
***** DONE Info->Legal текст не влезает
***** DONE Не отображается "Attributes Inspector" для точки монтирования
      Пока нет специального инспектора должен отображаться FolderInspector.
***** DONE D'n'D иконки из Shelf в другой .app удаляет ее
      И не только в .app, удаляет в любом случае если перетаскиваемая иконка
      покидает Shelf.
      DONE: Проверил в OPENSTEP - там так же. Очевидно, расположение иконки в
      Shelf имеет временный характер. Поэтому перемещение вне Shelf является
      одновременно и удалением этого объекта из Shelf. Кроме того, нет
      однозначного способа определить принята ли иконка приложением, в
      который был сделан drop или нет.
***** DONE File is not movable
      При операции перемещения появляется Alert с таким сообщением даже если
      все права разрешают сделать это.

      Разобрался: такое возникает при перемещении файла между разными ФС. Все
      дело в том, что в FileMover/Move.c используеться функция rename(),
      которая ругается в таком случае.
      Нужно:
      - для перемещения в пределах одной файловой системы использовать rename();
      - для перемещения между разными ФС использовать методы из Copy.m+Delete.m.
***** DONE D'n'D при большом кол-ве файлов
      Файлы просто не копируются.
      Вероятная причина: превышается максимально разрешенная длинна
      аргументов в символах (4096?).
      Нужно: придумать другой способ передачи списка файлов.
      Через env.
***** DONE Drop на иконку в Shelf не работает для точек монтирования
      Если иконку с точкой монтирования перетащить - начинает работать.
      Что-то не так с добавлением иконки в Shelf при монтировании?
      Все дело в [icon registerForDraggedTypes:], которое вызывается в
      [FileViewer shelf:didAcceptIcon:inDrag:].
***** DONE Перименование в FolderViewer глючит
      Вроде поправил, нужно еще раз все проверить.
***** DONE FileViewer: 2 клика на иконке в Shelf FolderViewer
      Если нажать 1 раз на иконку в Shelf весь путь в Browser отображается
      правильно. Если еще раз нажать на ту же иконку - последняя колонка пустая.
***** DONE Inspector: подвешивает весь Workspace...
      ...при открытии BuildDisk.app с сохраненным выбранным путем
      (English.lproj/clockbits.tiff). Сейчас повторить не удается...
      Посмотреть, что происходит с Inspector, когда он не может получить
      доступ к текущему окну FileViewer.

      Получилось повторить поведение при открытом и активном окне Processes.
      Исправил: если активно не окно FileViewer - пукты мнею Tools->Inspector
      должны быть не активны.
***** DONE При старте иконка media в PathView...
      ...не обновляется поскольку устройство еще не примонтировано, но mount
      point уже есть. Нужно обновлять иконки...
      Переместил выхов checkForRemovableMedia в Controller - теперь все OK.
***** DONE Browser: отображение пути к скрытому каталогу
      Если каталог скрыт (не виден в Browser), но может быть доступен для 
      выбора (например, через Shelf, вызов другого приложения, указания 
      прямого пути), Browser неправильно себя ведет. Как нужно себя вести?

      DONE:
      BrowserView вызывает [FileViewer directoryContentsAtPath:forPath:].
      Тот вызывает 
      [NXFileManager directoryContentsAtPath:forPath:sortedBy:showHidden:].
      В NXFileManager учитывается переменная, указанная в forPath. Если
      среди элементов пути есть скрытый каталог NXFileManager добавляет его
      в список видимых.
***** DONE Множественный выбор при сортировке от личной от 'Kind'
      После выбора нескольких файлов, выборка сбивается. Очевидно неправильно 
      отрабатывает displayPath:, который вызывается после того, как 
      отпускается кнопка мышки.
      DONE: Добавил метод directoryContentsAtPath (Viewers/FileViewer.m, 
      Protocols/FileViewer.h) для вызова из viewers. Также это место для
      будущих оптимизаций (кэширование, проверка на уже загруженный список
      файлов).
***** DONE Folder Inspector: перестал показываться
      После того, как - по какой-то причине слетели defaults Workspace -
      невозможно было получить значение @"DefaultDirSortOrder".
      Заменил на явное '0' (это тэг значения 'Name' в checklist).
***** DONE Размеры иконок в PathView и ShelfView
      Например, иконка Emacs обрезается сверху. Что-то не так...
      DONE: NXIcon-drawRect: использовать roundf() при определении точки,
      в которой нужно рисовать иконку и hilite
      NXIconLabel-adjustFrame: roundf(), fixes.
***** DONE PathView: иконки подпрыгивают при редактировании имени
      После клика в Browser или выбора другого объекта клавиатурой, все
      возвращается обратно.
      DONE: NSTextView изменял размер до того, как успевал отработать
      adjustFrame в NXIconLabel. Добавил [self setVerticallyResizable:NO].
***** DONE Файлы без права на чтение
      При выборе в FileViewer не обрабатывается такой случай.
      Если это был последний выбранный файл, после перезапуска, Workspace
      не показывает FileViewer. В консоли сообщение об exception.
      Для каталога нельзя:
      1. Получить список файлов
      2. Запустить монитор NXFileSystem
      Для файла нельзя:
      1. Прочитать содержимое
****** DONE Иконки для нечитаемых файлов и каталогов в PathView
       Показыввать их затененными, чтобы было понятно в чем дело.
****** DONE Inspector
       1. Attributes и UNIX Permissions для файлов должны отображаться
       2. Остальные должны показывать "No ... Inspector"
***** DONE AppInspector: проверять наличие Info-gnustep.plist перед чтением
***** DONE Inpector: UNIX permissions
      Похоже не меняет файлы вложенные в каталог при смене прав на каталог.
****** DONE Изменение прав и отображение в Browser
       При изменении прав с non-readable на readable для каталога, FileViewer 
       должен в Browser загрузить содержимое каталога и наоборот.
***** DONE Processes->Applications
      В режиме работы со сторонним window manager не нужно отслеживать запуск 
      приложений X11. Получаются приложения с PID=0.
      На самом деле проблема с запуском X11 приложений из .app wrappers.

      Сейчас Workspace виден 2 раза.

      Решение: регистрировать GNUstep application при получении уведомления
      NSWorkspaceDidLaunchApplicationNotification.
      X11 applications регистрируются так же с той лишь разницей, что
      NSWorkspaceDidLaunchApplicationNotification генерирует внутренний 
      WindowMaker через вызов xApplicationDidCreate (Workspace_main.m).
***** DONE Browser: обновление содержимого иногда глючит
      При открытом FolderViewer и обновлении содержимого (получения 
      уведомления от NXSystem)
***** DONE Browser: поиск при наборе на клавиатуре
****** DONE пропускает первую нажатую клавишу через раз
       Возможно все дело в буфере, который сохраняется между нажатиями.
****** DONE ... должен выполняться в последней видимой колонке (visible).
       Сейчас выполняется в последней выбранной (selected).
***** DONE Processes->Backrgound: пустой progress view
      Если панель Processes не была открыта при выполнении операции
      пользователем, а открывается после, в progress view (часть панели под 
      списком операций) остается надпись "No Background Process".
***** DONE В 'Tools Inspector' "Set Default" не работает
      Если сменить приложение по умолчанию, выбрав другой файл с таким же
      расширением получим старую программу по-умолчанию.
***** DONE При выборе файлов с помощью Alt+a (Select All)
      Файлы в Browser выделяются, но не происходит реального выделения
      (selection) в FileViewer. Соответственно иконка не меняется на
      иконку множественного выбора файлов.
      DONE: Добавил -slectAll: в BrowserMatrix и вызов sendAction изнутри.
      Но, выбираются файлы в последней выбранной колонке (колонка с
      последним каталогом в пути), а не файлы в посоледней колонке.
      DONE: Нужно будет в будущем разобраться с изменением положения и
      количеством колонок в разных ситуациях (перемещение стрелками
      вправо-влево, выбор файлов, клики на разных частях FileViewer...).
***** DONE Копирование залипает
      FileOperation находится в состоянии 'pipewr' или 'piperd'.
      'Stop', 'Pause' отрабатывает с переменным успехом.

      При этом, похоже, что FileOperation выбросил Alert ('piperd'), но в
      Processes панель с Alert'ом не отображается.
      
      С 'pipewr' вобще не понятно. 
      FileOperation не может записать в трубу?
      Workspace не может прочитать из трубы?

      DONE: FileOperation tool передает имена файлов с кириллическими
      именами. [FileOperation readInput] переводил data с входа в NSString
      в кодировке NSASCIIEncoding, получаются нули.
***** DONE При Duplicate и Copy неправильно отображается имя файла/каталога
      Зависит от фазы луны. Закономерность пока обнаружить не удалось.
      Возможно FileOperation не успевает получить вывод FileMover.
      Вывод FileOperation зависил от интервала в 0.1 секунду. В
      результате FileViewer не получал последнее обрабатывемое имя файла.
      Перенес проверку последнего обновления в [FileOperation
      updateOperationVew]. Это нужно для того, чтобы запросы на
      обновление к AppKit не были слишком частыми (не чаще 10 раз в
      секунду). Иначе в AppKit скапливаются в очереди запросы на
      обновление, которые скорее всего не будут обработаны (view
      уберется раньше, чем AppKit успеет все отобразить).
***** DONE Опять при выходе остаются висящими FileOperation
      Это связано с переписанным [FileOperation stop:].
      Если операция ожидает ввода [task interrupt] не работает.
      Нужно посылать "t".
***** DONE FileSystemInterface fileTypeAtPath
      fileTypeAtPath использует вызов к NSWorkspace. Для wrappers
      (.app, .gorm) возвращает NSPlainFileType.
      Для отображения во viewer это нормально, т.е. wrappers
      воспринимаются как обычные файлы (добавляется пустая колонка в
      browser, нет стрелочки).

      Но для случая если такой wrapper открыт как директория
      (File->Open as Folder)клик на home icon (111.gorm) wrapper
      воспринимается как файл и в PathView отображается так 111.gorm >
      111.gorm. Непорядок!
***** DONE FolderViewer home icon для wrappers (.app, .gorm)
      При двойном клике ничего не происхоит.
      DONE: В FileSystemInterface при выборе приложения для wrapper
      нужно было использовать абсолютный путь.
***** DONE Изменение ширины колонок Browser (влияние на PathView)
      Изменение ширины иконок в PathView ведет себя странно.
      FIXED: В [NXIconView adjustToFitIcons] не хватало финального вызова
      relayoutIcons
***** DONE Опять проблемы с дупликацией каталога
      Неправильная генерация целевого объекта - 'CopyOf' добавлялся в
      начало пути.
***** DONE Segfault при завершении файловой операции
      - Падает при удалении файловой операции из списка
      - Иногда падает при отправке notification из NXFileSysten

      Падает при файловых операциях где-то в 
      [XGServer(X11Ops) getEventMatchingMask:...] (XGServerEvent) и 
      [GSNotification dealloc] при копировании и открытом окне Processes на
      разделе "Background" и то не всегда.

      _Проблема №1_ - решена!
      NSTask с FileOperation освобождается (-release) лишний раз. 
      В mainThread это как-то проскакивало, в thread NXFileSystem - падало 
      при попытке освободить Notification.
      Решилось убиранием RETAIN из [FileOperation taskTerminated].
      *Классический случай преждевременной оптимизации!*

      _Проблема №2_
      Падение после FileOperation -dealloc.
      Предполагаемая причины:
         1. наличие notifications в очереди после dealloc'a.
         2. объект FileOperation уничтожается раньше чем завершается
            обработка вывода утилиты (находится внутри -readInput)
      Добавил lock'и для -updateOperationView и -readInput.

      -updateOperationView:
        + выполняется только при наличии объектов для обновления
          (fopBox и fopAlertBox);
        + ждет завершения предыдущей операции с помощью guiLock;
        + использует переменную currentView для определения box'а для
          обновления.
        + в NXProgressView заменил [self display] на [self
          setNeedsDisplay:YES] сразу перестал падать в некоторых
          случаях
        + в функции shortenString убрал -release переменной
          'shortString' стал реже падать при установке полей 'From:' и
          'To:'
      
      -readInput:
         + метод теперь reentrant (добавлен NSLock)
         + в конце работы NSTask, в методе -taskTerminated вызывается
           еще раз -readInput для того, чтобы подобрать вывод NSTask
         + для чтения вывода добавлен обработчик исключений.

      *Вывод*: основные проблемы были в новом коде в NXAppKit
      (NXProgress и NXUtilities)*.
***** DONE Segfault при клике на иконке
        Чтобы воспроизвести нужно:
          * кликнуть на иконке Shelf /Users/me/Developer/CUBE
          * пркрутить PathView в корень
          * кликнуть на иконке 'Users' в PathView
          * segfault

        Проблема более глобальная: падение возникает из-за
        установленного FirstResponder. Падение происходит в разных
        местах:
          * при вызове makeFirstResponder из
            BrowserViewer(displayPath:selection) - убрал
          * внутри NSView (removeFromSuperview - 
            вызов [_window firstResponder])

        Решается путем обнуления FirstResponder перед обновлением
        содержимого (например в [FileViewer displayPath:selection:sender:]) 
        [window makeFirstResponder:nil], с установкой FirstResponder
        на viewer [window makeFirstResponder:[viewer view]] после
        обновления отображения пути в разных местах.

        НО: нужно подумать о ситуации, когда обновление PathView и
        Viewer вызывается не из [FileViewer
        displayPath:selection:sender:]. Может "убегать" фокус
        (FirstResponder). FirstResponder у нас колонка BrowserViewer,
        поэтому добавил обнуление и установку FirstResponder в методы
        BrowserViewer. Проверил - не падает.
***** DONE "File->New Viewer" - падает если закрыть открывшееся окно
***** DONE Проверить добавление/удаление subview при операциях
      FileOperation subview
      FileOperationAlert subview
      Особенно обратить внимание на моменты окончания выполнения операции.
***** DONE Сделать [FileOperation updateOperationView] reentrant
      Добавить механизм блокировки (NSLock?).
      Не помогло. Теперь понятно почему.
***** DONE Создание, удаление каталога в FolderViewer
      Если создается каталог дальше корня - путь сбивается.
      При удалении каталога, путь тоже сбивается и приложение падает, 
      поскольку иконки уже нет.
      DONE(FileViewer.m): Закомментировал вызов
      validateAndDisplayPath:selection: в fileSystemChangedAtPath:.
      Теперь при переименовании в текущем окне выделение остается на
      переименованном файле, в другом(их) выделение перемещается по
      иерархии вверх.
      Удаление каталога/файла не приводит к падению.
**** TODO *Оптимизации/Улучшения*
***** TODO Сохранять состояние окон(minimized,shaded) при выходе
***** TODO [#A] Default sort method -> Kind
***** DONE [#A] Inspector: не вызывать если панель скрыта?
      Влияет на скорость прокрутки с помощью стрелок.
      Метод обновления (revert:) вызывается, но обновление не происходит если
      панель скрыта.
***** TODO [#A] Поддерживать системную настройку показа скрытых файлов
      Потребуется реализация в Preferences панели настроек 
      "Expert Preferences": блок "File System Options" опция "UNIX Expert".
***** TODO [#A] Processes: Расширить типами операций
****** TODO PermissionChanger-PermissionChanger.tool
******* PermissionChanger.tool
        Имеет смысл для FileAccessInspector, в том случае когда выбрана опция
        "Also apply to files inside selection" (для каталогов).
****** TODO Compressor-Compressor.tool
        Тут 2 варианта:
        1. Compressor вызывает 'tar zcvf <name>.tgz <name>' и парсит вывод.
           В этом случае Compressor.tool не нужен.
        2. Compressor.tool поддерживает разные форматы, позволяет выбрать в
           каком сохранить, с каким именем, и т.д.
        По-хорошему вариант 2 должен реализовываться с помощью отдельного
        приложения. А Workspace Manager должен обеспечивать базовую
        функциональность.

        NeXT Workspace Manager при выполнении комманды 'Compress':
        - создает для каждого выделенного файла/каталога отдельный архив;
        - удаляет исходные объекты.
        Похоже эта комманда появилась из-за маленьких дисков в то время.
        Поэтому 'Compress' можно воспринимать как: Compress files to reduce
        disk space usage.
        И еще, в OPENSTEP это .bundle с: инспекторами (archive и compress) и
        ProcessUI.

        Я же хочу фукнкциональность копирования выбранных файлов в .tgz
        для дальнейшего копирования/архивирования. Можно сделать так:
        - назвать пукт меню 'Archive...'
        - отображать панель с запросом имени архива если выбрано несколько файлов;
        - в панели предусмотреть галочку 'Archive and remove original files';
        - вызыввать 'tar zcvf' с выбранным именем и списком файлов;
        - удалять исходные файлы если галочка была поставлена;
        - создать ArchiveInspector, который будет отображать в 'Contents'
          список файлов для tgz и tar.gz архивов.
        Все это можно реализовать в Archive

******* Compressor.tool

****** TODO Disk->Initialize
***** TODO [#B] DnD: сделать режим Copy по-молчанию
***** TODO [#B] Разбандлить все приложение
      Что там у нас с NXBundle?
****** DONE inspectors.bundle - уже есть.
****** TODO preferences.bundle
****** TODO processes.bundle
       Панель и GUI отображение и управление операциями.
****** TODO compression.bundle
****** TODO compression tool
       compression GUI, инспектор для архивов.
****** TODO recycler.bundle
***** TODO [#B] Пересмотреть методы отображения/переименования в FileViewer
****** TODO Глобально отображать занятость окон через setDocumentEdited:.
       Все окна должны отбражать edited state при выполнении операций:
         - [ ] отбражении содержимого каталога (зависит от Viewer'a);
         - [X] выполненнии операций с файлами;
         - [X] монтировании/извлечении дисков;
         
         Но: для того, чтобы state действительно отображался, все операции
         должны быть асинхронными (см. 'File list lazy loading').
****** TODO FileViewer-fileSystemChangedAtPath
       Устроить ревизию [BrowserViewer reloadPath] и, возможно, включить
       его вызов из [FileViewer displayPath:selection:] для случая если
       выбранный путь не изменился. Далее из $subj можно будет вызывать 
       всегда только displayPath:selection.
****** TODO PathView: обработка множественного выбора
       Иконка MultipleSelection должна правильно устанавливаться/убираться с
       учетом использования "поумневшего" PathIcon и методов добавленных в
       Controller (NSWorkspace).
       Пока это делается ручным способом с использованием иконки PathView:.
       Некрасиво.
****** TODO PathView: сделать менее зависимым от BrowserViewer
****** TODO Browser: вызывать performClick по таймеру при движении стрелками
       ...для того, чтобы скроллинг стрелками был быстрым. Получается такая
       себе отложенная загрузка содержимого каталогов и метаинформации о файле
       (иконка, содержимое файла, и т.д.).
****** TODO Browser: сохранять позицию scroll при смене пути
       например при нажатии стрелки влево.
****** TODO Browser: file list lazy loading
       Подумать о вынесении задач по обновлении GUI в отдельный thread
       (NSTask|NSThread|GCD).
       Сейчас наблюдается задержка с появлением списка файлов, например для
       каталогоов типа '/boot/kernel'.
       Стоит подумать над реализацией алгоритма 'lazy loading' для
       BrowserViewer.
       
       Есть 2 проблемы:
       1. NSBrowser не рассчитан на такую модель использования: получаются
          недозагруженные колонки, путь устанавливается после загрузки всех
          колонок.
       2. PathView тесно взаимодействует именно с NSBrowser: согласование
          количества пустых колонок, установка клавиатурного фокуса и т.д. Это
          стоит поменять, поскольку любое непонятное поведение NSBrowser
          приводит к неадекватному состоянию PathView. Кроме того, IconView
          будет себя по-другому вести и как выглядеть PathView - непонятно.
       Итого: нужно серъезно переделать NSBrowser, чтобы такое было возможно и
       развязать PathView<->BrowserViewer.

****** TODO Проверить, чтобы все бандлы содержали используемые ресурсы внутри
       Например, иконки должны лежать не в Workspace/Resources, а в .bundle.
****** TODO Выход из Workspace в режиме файлового менеджера
       Выключение запущенных GNUstep приложений (подумать).
       Пока сделано при нажатии кнопки 'Power Off'. Нужно, чтобы это
       выполнялось при выборе 'Log Out'.
****** DONE В 'Attributes Inspector' кнопка 'Compute Size'
         BUG: Если кнопка нажата и до завершения процесса sizing'a
         переключиться на другой файл - процесс sizing'a не
         останавливается. В результате, посчитанный размер старой выборки
         отображается для новой выборки - ошибочное поведение!

         FIX: Сделать Sizer.tool - см. "FileOperation sizing течет".
         DONE: в методе revert: запущенный Sizer прибивается.
***** TODO [#C] Sizer любит память
      Например, при копировании '/Developer/Sources' процесс отъедает 120M
      ОЗУ. При копировании размер процесса, то увеличивается, то
      уменьшается.
      Уточнение: течет все, что использует [NSFileManager enumeratorAtPath].

      IDEA: Сделать Sizer.tool и запускать как задачу. При смене выборки -
      прибивать. Заодно и проблема с утечкой (enumeratorAtPath) будет
      решена. Нужно думать.
      Sizer.tool можно использовать в FileOperation и в 'Attributes
      Inspector'.

      Сделано: однако сам Sizer.tool отъедает кучу памяти и без enumeratorAtPath.
      Есть подозрение, что это из-за рекурсии, поскольку под каждый вызов
      метода резервируется память.
***** TODO [#C] File operations & NSWorkspace
      В API NSWorkspace предусмотрен механизм иницииации операции с файлами.
      Нужно сделать универсальный способ со всемы приседаниями 
      (notifications, etc.).
      Задействуются NSWorkspace, FileViewer, FileOperations, Processes.
      В общем, нужно подумать/посмотреть.
***** TODO [#C] DnD: Shelf, PathView
      - При добавлении иконки в Shelf, нужно явно вызыввать [FileViewer
        shelf:didAcceptIcon:inDrag:] - так ли это необходимо? 
***** TODO [#C] Реализовать -extendPowerOffBy:
***** TODO [#C] Иконки для разных файловых систем, fixed/removable media
***** TODO [#C] Добавить возоможность как-то монтировать образы дисков
**** TODO События Xrandr
**** TODO WindowMaker
***** ---- Мысли
      Как можно все реализовать теоретически:
      - WindowMaker собирается с минимальными изменениями в оригинальное дерево;
      - в код оригинального WM вноситься код с '#ifdef NEXTSPACE';
      - патчи затрагивают кроме собственно кода глобальные переменные в .h и .c;
      - настройки оригинального и встроенного WM не должны пересекаться:
        - оригинальный WM работает с иерархией каталогов $HOME/GNUstep;
        - встроенные работает с иерархией папок в $HOME/Library/:
          - Preferences/.WindowMaker - настройки: WMGLOBAL, WMRootMenu,
            WMState, WPrefs;
          - WindowMaker - рабочий каталог: CachedPixmaps, Themes, etc. 
      - WM собирается с путями под Workspace и '-DNEXTPACE';
***** ---- Функциональность
***** DONE Использование внутреннего/внешнего WMaker
      - стоит ли поддерживать разделение на WM и библиотеки?
      - может стоит использовать существующие библиотеки (в deb WindowMaker
        разделен на wmaker, wrlib и WINGs)
      - как сделать так, чтобы мои патчи накладывались на оригинальный
        WindowMaker?
      - возможность отключения сборки внутреннего WMaker

      Отвечу на все вопросы сокопом. Можно отказаться от разделения на
      библиотеки, но тогда потеряются изменения, которые жестко зашиты в
      исходники (например, пути к конфигурационным файлам (WINGs), настройки
      цвета панелей и меню (WINGs)). Во-вторых: если держать весь
      WindowMaker внутри Workdpace то можно сборку всех необходимых
      компонентов встроить в процесс сборки Workspace. В-третьих на каком-то
      этапе можно будет предложить патчи для добавления кода в upstream
      проект WindowMaker (иначе все равно прийдется как-то приводить тот код,
      который я наисправлял к виду пригодному для изговления патчей).
***** DONE Обновить версию внутреннего WMaker
***** DONE Размещение ресурсов WMaker
****** DONE ...переменные, установленные 'configure'
       В скрипте WM.configure.
****** DONE ...переменные, внутри исходных файлов (.h и .c)
******* DONE Патч WINGs/userdefaults.c:
         wusergnusteppath() возвращает GNUSTEP_USER_ROOT или $HOME/GNUstep.
         В ~/.xinitrc GNUSTEP_USER_ROOT=$HOME/Library.
******* DONE Патч WINGs/wcolorpanel.c
        makeColorPanel()
	- panel->configurationPath = wstrconcat(wusergnusteppath(), "/Library/Colors/");
	+ panel->configurationPath = wstrconcat(wusergnusteppath(), "/WindowMaker/Colors/");
******* DONE Патч src/dialog.c
        HistoryFileName()
	- filename = wstrappend(filename, "/.AppInfo/WindowMaker/History");
	+ filename = wstrappend(filename, "/WindowMaker/History");
******* DONE Патч src/icon.c
        - #define CACHE_ICON_PATH "/Library/WindowMaker/CachedPixmaps"
        + #define CACHE_ICON_PATH "/WindowMaker/CachedPixmaps"
******* DONE Патч src/main.c
        inotifyWatchConfig(void)
        execInitScript(void)
******* DONE Патч src/wconfig.h.in 
****** DONE ...шаблоны файлов настроек
******* DONE WindowMaker
******** DONE Вписать все существующие настройки
         Нужно поискать по WINGs, WPrefs.app, src.
         Трудозатратно. Так ли это нужно? Может когда-нибудь?
         По-идее все настройки перечислены в defaults.c в виде массивов.
******** DONE Добавить путь к Workspace.app/Resources
         Это нужно для того, чтобы можно было устанавливать иконку в Dock еще
         до старта Workspace.
******* DONE WMState
        См. также"Взаимодействие Workspace-WM:"->"Login/Logout/PowerOff"->
        "При запуске:"->"WMState".
********* DONE Наполнение Dock по-умолчанию:
          Находится в "/usr/NextSpace/Apps/Workspace.app/WindowMaker/WMState"
          и "/usr/NextSpace/etc/skel/Library/Preferences/WMState".
            - 0: Workspace
            - 1: Preferences, autolaunch
            - 2: TimeMon, autolaunch
            - 3: TextEdit
            - 4: Terminal
******* DONE WMGLOBAL - обновить
******* DONE Организовать размещение WM Defaults в:
        "/usr/NextSpace/Apps/Workspace.app/WindowMaker"
        Нужно внести изменения в GNUmakefile.postamble.
***** DONE (HACK) Правильное отображение appicon при первом старте
      На самом деле проблема глубже. Для приложений у которых нет окна - не
      появляется меню (даже если сделать правый клик на иконке).
      На данный момент проблема решена следующим образом: перед стартом
      Workspace NSApplicationMain устанавливается атом
      _GNUSTEP_FRAME_OFFSETS, которые читаются в
      gnustep-back/Source/x11/XGServerWindow.m _setupRootWindow.

      Такой способ не совсем правильный, поскольку при изменениии высоты
      заголовка окна или resize bar _GNUSTEP_FRAME_OFFSETS будут неверными (в
      них зашиты размеры 23 - titlebar height, 9 - resizebar height).

      Нужно брать параметр GSMenuBarHeight для titlebar, который все равно
      используется для определения высоты titlebar менюшек.

      Кстати, вроде в trunk'е GNUstep эту проблему решили - нужно проверить.
***** DONE Login:
****** DONE Старт Workspace как первого приложения
       А по-другому и не может быть.
****** DONE Проверка наличие и содержимого WMState
       Что делает WindowMaker если нет WMState ни в домашней директории,
       ни в ресурсах приложения (default)?
       Нужно ли создавать новый scr->session_state или WindowMaker это
       делает сам?
       Или?: если ~/Library/Prerences/WMState есть, но с ним что-то не так
       в результате чего proplist пустой - копировать WMState из ресурсов
       Workspace.app и перечитывать.

       Проверил: если файла ~/Library/Preferences/WMState нет, WindowMaker
       создает пустой Dock, в котором есть только
       иконка 0. Т.е. WindowMaker не копирует WMState из своих системных 
       ресурсов.
       Не проверял, но я думаю картина аналогичная для случая, если
       WMState некорректен. 

       Поэтому, вполне логичным будет проверка на наличие WMState. Если нет
       - копировать WMState из ресурсов Workspace.app. Все это нужно
       делать до инициализации WindowMaker.

       DONE: WWMStateCheck().
****** DONE WWMInitializeWindowMaker()
       Инициализируется WindowMaker без autolaunch приложений в Dock:
       - startup.c: Startup() -> wScreenRestoreState()
       - screen.c: wScreenRestoreState() -> wDockRestoreState()
       - Запретил исполнение main() в WM/src/main.c помощью #ifdef.
       - Сделал копию main(), оставил только то, что нужно и запретил
         принудительно autolaunch 'wPreferences.flags.noautolaunch = 1;'
       Устанавливаются необходимые параметры WindowMaker до и после 
       WindowMakerMain().
******* DONE Иконка в позиции 0,0 всегда Workspace
        В WWMInitializeWindowMaker() добавил код, который устанавливает
        параметры иконки 0. При выходе эти параметры сохраняются в WMState.
******* DONE Иконка 0 меняется на иконку в соответствии с ОС
        При старте WindowMaker (показывается док) и при старте Workspace
        (application устанавливает картинку в appicon).
        На самом деле, смысла особго нет, поскольку appicon рисуется
        GNUstep. Поэтому пока оставлю без особых изменений - иконка
        устанавливается в applicationWillFinishLaunching.
****** DONE NSApplicationMain()
****** DONE Инициализация ProcessManager и выполнение Dock autolaunch
       ProcessManager - для регистрации приложений.
       Dock autolauch - для запуска приложений, которые первыми зарегистрируются.
       Workspace не должен запускаться: иконка в позиции 0 помечается как
       незапускаемая на этапе проверки WMState.
       Сделано в Controller.m -applicationWillFinishLaunching.
****** DONE Регистрация приложений GNUstep и XWindow в ProcessManager
******* DONE Определить PID запущенного приложения X11
******* DONE Подокна без PID приложения нужно игнорировать
******* DONE Закрытие одного окна приложения X11 не должно удалять приложение из списка
******* DONE Кнопка 'Kill'
        - приложения GNUstep нужно удалять из списка
        - для приложений X11 должны убиваться все PID
******* DONE Обновлять информации о PID приложения
        Если это делать по вызову из кода WindowMaker - падает при обновлении GUI.
        Сделать это через NSTimer? Через NSTimer не получилось. Напрямую - работает.
******* DONE Что делать с приложениями без PID ("-1")
        Варианты:
        1. Показывать для информации, без возможности их останова из
           Workspace (так сделано сейчас).
        2. Уменьшить количество таких приложений. Например, путем модификации
           кода приложений-мониторов (coding style?), для остальных - как в
           п.1.
        3. Не показывать в списке приложений при создании и игнорировать их
           удаление. Оставить управление такими приложениями WindowMaker'у.
****** DONE Появление окон Workspace
***** DONE Logout/PowerOff:
****** DONE останавливаются приложения GNUstep 
       - [procManager terminateAllBGOperations];
       - [procManager terminateAllApps];
****** DONE закрываются окна Workspace 
       - [Contoller _closeAllWindows];
****** DONE размонтируются media
       - [mediaAdaptor ejectAllRemovables];
****** DONE выполняется выход из WindowMaker
       - WWMShutdown(WSKillMode);
       - останавливаются приложения XWindow - WWMWipeDesktop();
****** DONE выполняется выход из Workspace 
       Пока по 'Log out' выполняется просто выход из приложения, если выбран
       'Power Off' - останавливаются приложения.
       После того, как будет закончена основная функциональность будет так:
       - Log out - выход с закрытием всех приложений;
       - Power Off - Logout + отправка сообщения Login.app.
***** DONE Applications
      WindowMaker сообщает Workspace о запускаемых/останавливаемых
      приложениях X Window;
      Workspace отображает приложения в Processes-Applications;
****** DONE Приложения X11 в Processes
       Регистрация/дерегистрация приложений Xlib (Processes->Applications)
****** DONE Регистрация запущенных приложений до полного запуска NSApp
****** DONE Корректный останов (Kill) приложений из Processes
****** DONE Релизация 'pidof'
       Нужно реализовать ОС-незаивисимый способ определения PID приложения?
       Пока не вижу смысла.
       На текущий момент PID определяется для:
         - приложений GNUstep через
           NSWorkspaceDidLaunchApplicationNotification с последующим
           вытаскиванием PID из userInfo этого notification.
         - для приложений X11, определяется PID для окна приложения
           xPIDForWindow() в Workspace_main.m
***** TODO Единый Look&Feel (WM+WM)
****** ---- Мысли
       Для перелетания иконок при запуске сновная задача понять как
       вычисляется в WindowMaker координаты следующей иконки внизу (Icon
       Yard). После этого нужно реализовать:
       - перелетание иконки из Workspace вниз (координаты уже известны);
       - отображение иконки до появления приложения (с каким
         wm_instance.wm_class?);
       - перевод иконки внизу в состояние launching;
       - WindowMaker ловит первое окно приложения;
       - WindowMaker переводит иконку в состояние launched;
       - WindowMaker рисует иконку от приложения или из WMWindowAttributes.
       
       То же с Dock только проще - иконка уже есть и ее можно вычислить из
       информации о Dock.
****** TODO Focus
******* ---- Проблемы
       Основные проблемы возникают при старте приложения и первоначальном 
       фокусировании. Сейчас после старта фокус находится на меню даже
       если есть открытые окна.
       По-идее это должно работать так:
        - appicon: XCreateWindow, XMapRaised - иконка получает InputFocus;
          предыдущее приложение теряет фокус, меню еще не появилось;
          если приложение было запущено с опцией -NXAutoLaunch текущее актвное
          приложение фокус не теряет.
        - если '-NXAutoLaunch NO': создается и отбражается меню, меню 
          получает InputFocus;
        - создается обычное окно, окно получает InputFocus;
        - обычное последнее окно закрывается - фокус переходит к меню.
******* TODO Старт приложений с опцией '-NXAutoLaunch YES'
        Ожидаемое поведение:
        - Запускаеся и отображает appicon
        - Меню НЕ отображается
        - Фокус на приложение НЕ передается
          На текущем приложении фокус не "моргает".
        - Shortcut'ы не работают
          Приложением НЕ перехватываются и НЕ обрабатываются.

        В реализации участвуют несколько элементов:
        - NSMenu.m (_showActivateApp):
          - вызывается как callback на
            notification NSApplicationWillBecomeActiveNotification (шлется из
            NSApplication.m activateIgnoringOtherApps:);
          - отображает mainMenu только если параметр -NXAutoLaunch не
            установлен в YES.
        - NSApplication.m (activateIgnoringOtherApps:): -NXAutoLaunch
          убирается в конце метода для того, чтобы при следующем вызове метода
          (например, двойной клик на иконке) главное меню было отображено.
        - XGServerWindow.m (orderwindow::::): если -NXAutoLaunch == YES:
          - отправляется сообщение WindowMaker'у игнорировать изменения фокуса
            (с помощью атома "WM_IGNORE_FOCUS_EVENTS");
          - отображается appicon (XMapWindow для group leader - ROOT);
          - отправляется сообщение WindowMaker'у обрабатывать изменения
            фокуса.
          Это самое важное в процедуре активации приложения с опцией
          NXAutoLaunch, и вот почему. При отображении group leader (ROOT)
          происходит отображение NSIconWindow, но WindowMaker пытается
          передать фокус на окно ROOT. Поскольку group leader никогда не
          отображается (и не предназначен для этого) WindowMaker передает
          фокус на служебное окно no_focus_window (размер 4x4, расположено за
          передалами видимости, координаты -10,-10). После этого фокус
          возращается в окну (приложению), которое было до этого
          активным. Как результат, статус окна "моргает" (с активного на
          неактивный, далее с неактивного на активный), но приложение
          почему-то не получает клавиатурный фокус.

          Скорее всего ошибка в коде обработке FocusIn/FocusOut в
          gnustep-back (XGServerEvent, XGServerWindow). Нужно дополнительное
          изучение этого вопроса.

          Кстати возможно hack с переключением фокуса при изменении
          Workspace неправильный. Тоже нужно посмотреть более внимательно.
          Плюс, описанное выше поведение может проявлятся в других местах. По
          карайней мере я такое наблюдал и не раз. Нужно смотреть в код
          XGServerWindow, XGServerEvent.

******* TODO Старт приложений без окон (только меню)
******** DONE отображается appicon с "забеленной иконкой"
         Только в случае старта из Workspace.
         Будет сделано при решении задачи "Dock и IconYard->Workspace:
         перелетание иконки из Workspace в IconYard" 
******** DONE отображает appicon с нормальным видом иконки
******** DONE появляется меню и приложение получает фокус
******** DONE shortcut'ы работают
         Приложением перехватываются и обрабатываются.
******** TODO приложение присутствует в списке при переключении по Alt-Tab
         Сейчас единственно окно - меню - помечено как такое, которое
         исключается из списка окон. Нужно ли включать?
         В NEXTSTEP не используется такой shortcut - все переключение между
         окнами выполняется с помощью мыши (на окне, на appicon).
         Как это стоит реализовать?
         Очевидно, нужно менять логику работы Focus*Key в WindowMaker-
         показывать только по одной иконке на приложение. Переключение между
         окнами должно работать через другой shortcut (Group*Key).
******* DONE Приложение с одним окном
        - При старте тоже, что и приложения без окон, но клавиатурный ввод
          переправляется в активное (key) окно.
        - Двойной клик на appicon неактивного приложения делает окно
          активным, клавиатурный ввод получает окно (shortcut'ы мены
          обрабатываются меню).
******* DONE Приложение c несоколькими окнами
******** DONE Активация кликом на appicon
         Двойной клик на appicon неактивного приложения делает активным окно,
         которое было активным до деактивации приложения. 
         Клавиатурный ввод получает окно (shortcut'ы мены обрабатываются
         меню).
******** DONE Активация кликом не заголовке окна
         Клик на заголовке окна неактивного приложения активирует приложение
         и делает активным окно независимо от того было это окно активным до
         деактивации приложения или нет.
******* DONE Приложение с окном(ами) и панелями (utility, modal)
******** DONE Активация кликом на appicon
         Также как с "Приложение с несколькими окнами". Фокус получает то
         окно/панель, на котором был фокус до деактивации.
******** DONE Активация кликом не заголовке окна
         Также как с "Приложение с несколькими окнами".
******* TODO Клик внутри окна
        Варианты (как там в OPENSTEP?):
        1. Фокус получает то окно, на котором НАЖАЛИ кнопку мыши.
        2. Фокус получает то окно, на котором ОТПУСТИЛИ кнопку мыши.
        3. Фокус окно не получает если из неактивного окна что-то перетащили.
******* TODO Клик на заголовке окна
        Варианты (как там в OPENSTEP?):
        1. Фокус получает то окно, на заголовке которого НАЖАЛИ кнопку мыши.
        2. Фокус получает то окно, на заголовке которого ОТПУСТИЛИ кнопку мыши.
        3. Фокус окно не получает если его перенесли.
******* DONE (HACK): Переключение фокуса
      Фокус должен возвращаться к Workspace если нет приложений,
      которым его можно установить:
        * Workspace в applicationDidFinishLaunching передает
          WindowMaker окно appicon в WindowMaker;
        * WindowMaker запоминает это окно в структуре WScreen как
          no_focus_window (startup.c SetupNoFocusWindow);
        * WindowMaker вызывает wSetFocusTo (actions.c), в котором
          устанавливается фокус ввода (XSetInputFocus) на
          no_focus_window и вызывается активация приложения
          Workspace (xActivateWorkspace) через dispatch_async. Если
          не использовать dispatch или использовать dispatch_sync
          ввод/вывод замирает.
         Workspace падает при переключении между workspace'ами.
         27.12.2013: не падает (возможно какие-то последние правки помогли).
         Похоже это что-то неспецифичное для WindowMaker.
****** TODO Окна и меню
******* TODO NS*WindowLevel
        Это какая-то жесть. В NSWindow.h NSFloatingWindowLevel,
        NSSubmenuWindowLevel и NSTornOffMenuWindowLevel = 3!!!!!!!
        В комментарии написано, что эти значения взяты из WindowMaker, но не
        совпадают с MacOS потому, что значения в WindowMaker не могут быть
        изменены. Нужно что-то с этим делать.

        После беглого осмотра WindowMaker видно, что WindowLevel используется
        для ранжирования окон в стэке (ChangeStackingLevel в stacking.c). По
        сути нигде даже не используются имена элементов из enum. Используются
        только числовые значения. Поэтому можно спокойно менять цифры в
        NSWindow.h. Нужен более детальный анализ этого...
******* TODO Появление окон Workspace
        Когда показывать окна - параллельно или дождатся старта приложений,
        помеченных как autolaunch в Dock? Если не дожидаться - моргает фокус
        на запускаемых приложениях GNUstep.
        На самом деле это вопрос правильного запуска приложений GNUstep без
        отображения меню и регистрации приложений WindowMaker'ом 
        (см. "Focus->Старт приложений без окон"). Нужно думать...
******* TODO WindowMaker: После перезапуска приложения съзжают вниз
        Если Workspace (WindowMaker) подхватывают уже запущенные приложения,
        добавление заголовка окна (WM) визуально опускает содержимое окна на
        высоту заголовка. Это может понадобится при перезапуске Workspace
        (падение, kill -9).
******* DONE GNUstep: Размер заголовка меню должно быть равно 23
        При большем/меньшем размере WindowMaker масштабирует кнопки в
        заголовке, выглядит это для стиля NeXT(old) не очень.
        Плюс, это фактический размер заголовка окна в WindowMaker.
        Настройка GSTheme*:
        $ defaults write NSGlobalDomain GSMenuBarHeight 23
        Добавил в System/etc/skel/Library/Preferences/NSGlobalDomain.
******* DONE Highlight кнопок в заголовке окна
        Кнопки должны не нажиматься, а подсвечиваться.
        DONE: src_framewin.c.patch
******* DONE Размер заголовка окна и кнопок в заголовке
        Сейчас размер заголовка,и, как следствие, размеры кнопок больше
        чем в OPENSTEP при визуально одинаковом размере шрифта.
        Пока решил установкой настроек в ~/L/P/.WindowMaker/WindoMaker:
        - WindowTitleMaxHeight = 22;
        - WindowTitleMinHeight = 22;
        - MenuTitleMaxHeight = 22;
        - MenuTitleMinHeight = 22;
        Правда откуда-то берется еще один пиксел. Поэтому в GNUstep нужно
        учитывать высоту заголовка равным 2
****** TODO Dock и IconYard
******* TODO Иконка 0
       - иконка 0 в доке не должна показывать статус незапущенного приложения
         (троеточие) всегда;
       - иконка 0 должна иметь всегда одно и то же изображение на разных
         этапах старта Workspace;
******* TODO При старте размещать Dock и Icon Yard на primary display
        Вроде уже сделал. Нужно проверить.
        Могу залипнуть в Preferences.app/Display. :(
******* TODO Workspace: управление появлением/скрытием Dock и IconYard
******* TODO Перетаскивание иконки приложения из Workspace в Dock
******* TODO Workspace: перелетание иконки из Workspace в Dock
        Сделано пока только для приложений GNUstep.
        Видятся следущие шаги:
        1. Узнать у Dock есть ли иконка с таким приложением.
        2. Определить координаты иконки.
        3. Перелететь иконку из Workspace в Dock.
        4. Засветить иконку.
        5. Запустить приложение.
******* TODO Workspace: перелетание иконки из Workspace в IconYard
        ...потом создать иконку, показать иконку и засветить ее.
******* DONE Вид miniwindow
******** Preface
         Между WindowMaker и GNUstep есть разница.
         Нужно привести к одному виду, ориентиуясь на OPENSTEP.
         Сейчас у art и WindowMaker разный тип hinting'а - нужно привести в
         соответствие.
         Для GNUstep есть патчи. Для WindowMaker нужно:
         - изменить рисунок заголовка;
         - посмотреть что там с антиалиасингом и хинтингом мелких шрифтов.
******** DONE рисунок заголовка
         Сделать рисунок заголовка miniwindow таким же, как у GNUstep.
******** DONE ширина заголовка
         Сейчас текст рисуется с начала иконки. Поэтому часть изображения
         заголовка (не черная) затирается текстом.
         Это происходит из-за antialias текста и заголовок рисуется с
         координатой по X=-1. Решено путем установки минимального значения X=2.
         Шрифт для miniwindow нужно сделать без antialiasing.
******** DONE шрифт
         Посмотреть что там с антиалиасингом и хинтингом мелких шрифтов.
         Ситуация такая:
         - вид шрифта конфигурируется через fontconfig. При этом атрибут
           'antialias' в названии шрифта игнорируется (почему?).
         - в заголовке окна шрифт рисуется как bitmap потому, что используется
           модифицированный мной шрифт; если использовать оригинальный
           'Helvetica World' и включить антиалиасинг в fontconfig - все шрифты
           рисуются сглаженными.
        Таким образом вид шрифта в WindowMaker задается:
        1. Настройками в .fonts.conf.
        2. Указанием настроек "xxxFont" в ~/L/P/.WindowMaker/WindowMaker.
****** TODO Workspace: отображение текущего 'WM workspace'
****** TODO Workspace: некрасивые иконки в Processes
       Иконки приложений X11 в Processes (получены от WindowMaker) некрасивые.
       При запуске еще одного окна приложения X11 иконка "ломается".
****** TODO WindowMaker RootMenu
       Что с ним делать?
       Нужно допилить работу Workspace->Tools->Launcher и тогда можно
       обойтись без RootMenu, из которого я запускаю диалог "Run" и xterm.
****** TODO Виджеты WINGs
******* TODO Цвет
        Пока без диалогов WINGs полностью не обойтись, поэтому нужно привести
        цвет в соответствие с GNUstep.
******* TODO Оставить только нужные
****** TODO Workspace: перезапуск при падениях, kill и т.д.
       Нужно подумать как организовать Restart Workspace без участия
       Login.app.
****** TODO WPrefs.app и настройки
******* TODO Получить список всех настроек и возможных значений
******* TODO Выбрать расширенные настройки и определить нужные для NEXTSPACE
        Нужно поискать по WINGs, WPrefs.app, src. 
        Трудозатратно. Для чего это нужно?
        Это нужно для добавления этих настроек в Preferences.app.
******* DONE Настройки WindowMaker: WPrefs.app или Preferences.app?
        WPrefs.app не работает из-за того, что требуется какая-то странная
        связь между WindowMaker и WPrefs.app, завязанная на бинарнике 'wmaker'.
******* DONE Переписать WPrefs.app на GNUstep?
        В WPrefs.app можно оставить только расширенные настройки.
        Нет, добавить необходимые настроки в Preferences. Возможно в виде
        отдельной панели "Window Management".
******* DONE DEFAULTS_DIR
        Присутствует в двух местах:
        - WINGs/userdefaults.c
        - src/wconfig.h(.in) - нигде не используется (WTF?).
        Патчи подготовлены. Помечу задачу как DONE, поскольку я не знаю, что с
        этим делать (у меня пока нет задачи сделать из WindowMaker конфетку).
****** DONE Перетаскивание Dock вниз работает неправильно
       Как только иконка скрывается снизу, она тут же появляется сверху.
       Нужно установить 'WrapAppiconsInDock=NO' в Preferences/WindoMaker.
****** TODO internal X error: BadMatch
       Отсуствие сообщений вида "internal X error: BadMatch (invalid
       parameter attributes)" (например, при отображении меню  приложения
       GNUstep по правому клику на appicon);
       Давно уже не было видно... Правда Xxkb выдает сообщение "Xxkb: Unknown
       event 23".
****** TODO (?)Workspace: запуск/останов приложений в Dock
       Управление запуском (при входе) и остановом (при выходе) из Workspace.
       Другими словами не использовать встроенную функцию WindowMaker.
****** TODO (?)WindowMaker: управление отображением иконки внизу приложений GNUstep и XWindow
****** TODO (?)WindowMaker: управление отображением иконки в Dock...
       ...приложений GNUstep и XWindow если приложение запущено кликом на
       иконке в Dock;
***** TODO Recycler
      - иконка в Dock - создавать программно из при старте Workspace; если в
        Dock нет места - располагать как appicon внизу;
      - D'n'D в иконку из Workspace;
      - окно с файлами в Recycler (~/.Trash? а как с другими дисками?);
      - File->Empty Recycler;
******* TODO Иконка в доке
        - ее нельзя удалить из Dock (Lock=Yes в WMState);
        - если нет свободного места, появляется внизу.
**** TODO Взаимодействие с Login
***** TODO Log Out
***** TODO Power Off
      Workspace отправояет Login сообщения о PowerOff если выбран режим выхода
      'Power Off'.
**** DONE Управление съемными накопителями: CD/DVD, USB
***** DONE Проверить реакцию при NXFileSystemChangedAtPath
      Все, что находится внутри [FileViewer fileSystemChangedAtPath]
      проверено. Нужно еще проверить граничные случаи.
***** DONE Удаление корня Folder Viewer с файлами
      NXFileSystemMonitor генерирует много "Write, Delete" для файлов,
      которые удаляются из каталога. FileViewer не воспринимает это как
      удаление корневого каталога и пытается обновиться с последующим
      падением всего Workspace.
***** DONE Rename в Workspace
**** DONE Все пункты меню должны быть активны к месту
****** DONE Элементы меню Disk
******* DONE ...должны быть активны к месту
        validateMenuItem нужно располагать там, куда указан target для
        конкретного menu item. В данном случае это FileViewer.
******* DONE ...должны работать во всех File Viewer
****** DONE Элементы меню File...
**** DONE Console: расположение, способ вывода
     Вывод делается в /tmp/GNUstepSecure<id -u>/console.log. Это секурно, лог
     удаляется при выходе из сессии (я, правда, не уверен, что это правильно).
***** DONE Консоль должна миниатюризироваться
**** DONE Добавить сахара...
***** DONE Сделать иконку приложения по типу ОС
      CentOS, BSD. И NeXT если нужно будет полное впечатление от OPENSTEP.
***** DONE Info->Info Panel устанавливать иконку по типу ОС
***** DONE Добавить Legal Panel...
**** DONE Переместить alert'ы на события NXMediaManager в Controller
     При выходе Workspace иногда сегфолтиться.
     Плюс не все AlertPanel (с предложением отключить устройство) показываются.

     Предположение: в процессе выхода, AlerPanel выскакивает по уведомлению
     о unmount/eject. Этот AlertPanel может выскочить в процессе (или после)
     -dealloc FileViewer'a.

     Нужно: переместить выскакивания панелей в Controller.m. Таким образом,
     панель безболезненно может выскочить после закрытия всех FileViewer'ов.
     В FileViewer'ах остаются действия, связанные с обновлением содержимого
     Shelf, Browser, PathView.
**** DONE FileVewer: разобраться с isRootViewer, isFolderViewer
     RootViewer - тот, что без иконки минимизации в заголовке
     FolderViewer - открытый через "Open as Folder"
     !RootViewer и !FolderViewer - копия RootViewer:
     - помещает иконки смонтированных устройст если key window;
     - со старта содержит все иконки, включая смонтированных устройств;
     - не сохраняет своего состояния: такой себе временный isRootViewer; как
       следствие не влияет на RootViewer (например, можно убрать все иконки из
       Shelf, закрыть затем открыть снова и он будет опять как копия
       RootViewer)
**** DONE Выход из приложения: переосмыслить, описать, переписать
     Посмотреть что за чем закрывается, какие события могут произойти в этот
     момент, как эти события повлияют на стабильность приложения и его коллег.
     Вроде все нормально, только:
     - если нажать "Log out" или "Power off" с помощью клавиатуры, Workspace
       стабильно вываливается в segfault. Что-то в GNUstep?
     - 'fileSystemMonitor' не делает -dealloc. Потому, что thread?
**** DONE Processes:
****** DONE ProcessManager (фоновые операции без GUI)
****** DONE BGOperation (concrete)
****** DONE FileMover->FileMover.tool
******* DONE FileMover
       Как вызывать Sizer (Sizer:BGOperation или Sizer.tool)? 
       Как получить информацию от Sizer: парсить вывод Sizer.tool или ждать
       какой-нибудь Notification от Sizer:BGOperation?

       Вариант 1 (без привлечения Sizer:BGOperation):
       - вызвать Sizer.tool через NSTask;
       - рапортовать Processes о типе операции 'Size', но title, например,
         'Copying files from /path/to/directory...';
       - отображать в FileMoverUI "Sizing <имя файла/каталога>...";
       - парсить его вывод в readInput и передавать в FileMoverUI;
       - дождаться заверешения NSTask с Sizer.tool;
       - запустить NSTask с FileMover.

       Вариант 2 (с привлечением Sizer:BGOperation):
       - создать и вызвать Sizer:BGOperation (асинхронная операция,
         порождается NSTask);
       - Sizer отображает себя в BGProcess (SimpleBGProcess.gorm);
       - дождаться NSNotification с:
         - (Q)ueued(F)iles - NSNumber;
         - (Q)ueued(S)ize - NSNumber;
         - SkippedFiles - NSArray;
         - IsStopped - YES|NO (если вдруг операция Size была прервана пользователем);
       - запустить NSTask с FileMover если IsStopped == NO.

       Выбран вариант 1.
******* DONE FileMover.tool
        Получает на вход:
        - Operation <*NSString> (тип операции)
        - Source <*NSString> (путь каталога-источника)
        - Destination <*NSString> (путь каталога-назначения)
        - Files <*NSString=[NSArray description]> (список файлов в операции)
        - FileCount <*NSNumber> (количество файлов)
        - FileSize <*NSNumber> (объем файлов)****** DONE Sizer->Sizer.tool
       Должен ли Sizer:
       - сообщать о невозможности прочитать аттрибуты файла?
       - проверять возможность выполнить действие в зависимости от операции?
       Если ответы - Да: 
       - как передать принятые пользователем решений конкретной операции (все,
         кроме 'Disk')?

       Ответ: Нет. Может когда-нибудь...
****** DONE Sizer->Sizer.tool
******* DONE Сделать Sizer
******* DONE Сделать отображение в Processes (BGProcess?)
******* DONE Использовать новый Sizer в "Attributes Inspector"
******* DONE Проверить работу и отображение на примере "Attributes Inspector"
******* DONE Sizer.tool
        Запускается как NSTask, выполняет быстрый сбор информации о файлах для
        отображения прогресса выполнения операции.
        Получает на вход: -Source, -Files
        Выдает на выход: количество файлов, объем всех файлов в операции
****** DONE Mounter
       Отображает статус операций Mount, Unmount, Eject.
******* DONE Eject для CD/DVD не убирает BGProcess
****** DONE Processes (отображение и управление приложениями и фоновыми операциями):
      - GORMs: Processes
      - загрузка и отображение ProcessesPanel (меню, по просьбе подчиненных процессов);
      - хранение текущих активных фоновых процессов (<NSObject>, <NSObject>,...);
      - отображение списка объектов в зависимости от режима (Applications,
        Background) - один NSTableView загружаются объекты при смене режима;
      - отображение status view и alert view в ProcessessPanel при выборе
        объекта из списка;
      - при отображении alert view ProcessPanel должен обращать на себя внимание;
      - запуск файловых операций: SizerProcess, затем FileProcess;
******* DONE Processes (AppProcess):
      - GORM: AppProcessUI (нижняя часть окна Processess);
      - методы реакции на действия пользователя (Kill);
      - обновление состояния AppProcessUI в ответ на события (закрытие,
        изменения состояния, атрибутов);
      - загрузка информации о приложении (PID, Path, Status);
      Итого: по сути это текущий Processes.m без фоновых процессов.

******* DONE Processes-Background надпись
        Если процесс Sizing слишком быстрый (копируюется один большой файл)
        надпись в панели Sizing... вместо Copying...

        Исправлено.
        Проблема была в том, что если выполняется операция с одним файлом - операция
        меняется, а имя файла - нет. Tool просто не передавал сообщение операции.
****** DONE BGProcess
       - загружает SimpleBGProcess.gorm
       - возврщает miniIcon, processView;
       - отвечает на stop;
******* DONE Mounter->BGProcess
******* DONE Sizer->BGProcess
******* DONE FileMoverUI : BGProcess
      - получает на вход от ProcessManager информацию о:
        - типе операции
        - каталогах: источнике и назначении
        - списке файлов
        - количестве файлов
        - объеме файлов
      - вызов Sizer.tool и получение информации для ProgressBar;
      - вызов FileOperation.tool, получение и отображение прогресса в FileProcess.gorm
      - при получении на вход от FileOperation.tool сообщение об ошибке
        заменить FileOperation.gorm на FileOperationAlert.gorm (как это пока вопрос)
**** DONE Выход из Workspace
***** DONE Запоминать открытые окна
***** DONE При старте восстанавливать открытые окна
***** DONE Выход
     - [X] запоминать окна FileViewer'a
     - [X] запоминать если открыта консоль
     - [X] остановить все фоновые операции и дождаться их завершения (если не
       дожидаться, то операция может не дать размонтировать media)
**** DONE Монтирование/демонтирование (NXMediaManager)
***** DONE При выходе из Workspace нет панели с сообщением "You can safely..."
***** DONE Отображать в Processes-Background процесс монтировани/демонтирования
***** DONE Окно с при unmount должно закрываться
***** DONE Панель после eject/poweroff
******* DONE ...для USB
        Notification от [*Adaptor _removeUDisksObjectWithPath] 
******* DONE ...для SD
        Notification от [*Drive unmountVolumeAndDetach].
***** DONE Панель после unsafe detach
       Notification от [*Drive unmountVolumeAndDetach].
***** DONE Панель при ошибке выполнения операции
       Notification от [*Adaptor _updateJob:objects:signal:parameters:].
***** DONE Автоматическое монтирование съемных накопителей при старте
**** DONE Inspector [10/10]
***** DONE Файловык ассоциации [6/6]
****** DONE Реализовать определение типа файла с помощью 'libmagic'
       Реализовать более умную схему опеределения типа приложения.
       Открывать TextEdit только для текстовых файлов.
       В Controller+NSworkspace -> getInfoForFile:application:type
       DONE: добавил определение MIME type в _iconForFileContents.
       Используются методы, реализованные в NXFoundation/NXFileManager.m
       Мысли:
       1. MIME type нужен для опеределения иконки и запускаемого приложения
       2. Description нужен в Inspector.
****** DONE Открывать в текстовом редакторе в случае целесообразности
       DONE: Добавил параметр 'DefaultEditor=TextEdit.app;' в
       Workspace.ospl.
       Используется в методах:
       - openFile:withApplication:andDeactivate:
       - openTempFile:
      _openUnknown: не нужен, удалил.
****** DONE Методы FileSystemInterface -> Controller+NSWorkspace
        Не обращаться к NSWorkspace вобще. Использовать только методы
        реализованные внутри. 
        Глобально, внутренние методы это то, что должно вызываться NSWorkspace
        в AppKit.
******** DONE fileTypeAtPath: -> getInfoForFile:application:type:
******** DONE iconForFile:
******** DONE openFile:fromImage:at:inView:
         А также все методы, начинающиеся с openFile:
         openFile: 
           -> openFile:withApplication
         openFile:withApplication: 
           -> openFile:withApplication:andDeactivate:
         openFile:fromImage:at:inView:
           -> openFile:withApplication:andDeactivate:
         Перенес openIconForDirectory в Controller+NSWorkspace.m
****** DONE Реализовать методы _workspaceApplication (NSWorkspace)
        DONE: перенес NSWorkspace.m в Controller+NSWorkspace.m так, чтобы
        соответствовало спецификации OpenStep.
        Методы NSWorkspace в GNUstep, которые вызывают Workspace Manager.
        Приложение устанавливается в NSGlobalDomain, ключ
        @"GSWorkspaceApplication".
        OpenStepSpec/ApplicationKit/Classes/NSWorkspace.htmld/index.html
******** DONE getInfoForFile:application:type
******** DONE openFile:*
******** DONE iconForFile:
******** DONE iconForFiles:
******** DONE iconForFileType:
******** DONE performFileOperation:source:destination:files:tag
******** DONE selectFile:inFileViewerRootedAtPath:
******** DONE findApplications
****** DONE Опеределять приложения при старте
        DONE: [[NSWorkspace sharedWorkspace] findApplications];
****** DONE Обновлять меню Services при старте (make_services)
        В нем ничего не отборажаеся. Нужно разобраться в чем проблема.
        Разобрался. Нет ни одного приложения с описанными в
        Info-gnustep.plist сервисами (NSServices {};).
        Список сервисов обновляется с помощью утилиты 'make_services'.
        При добавлении/установке приложения, которое предоставляет
        сервис порядок действий такой:
         1. Приложение копируется в /Applications.
         2. Запускается 'make_services'.
         3. Workspace перезапускается (через logout/login).
        DONE: 
        * То, что описано работает. Главное правильно описать сервис в файл
          Info-gnustep.plist.
        * Добавил вызов 'make_services' в настройки Login (LoginHook).
        * Убрал вызов 'make_services' из настроек Login (LoginHook). Этим
          должен заниматься Workspace.
***** DONE Архитектура, наследование:Inspector, WMInspector
****** DONE Активация инспектора
       * activateInspector - используется только в Inspector:
       * revert - the must для подклассов:
         + используется при:
           - инициализации инспектора (не должен вызываться из
             activateInspector);
           - нажатии кнопки 'Revert';
           - смене выборки в FileViewer;
         + функциональность:
           - получает имена выбранных каталога и файлов;
           - получает нужную информацию об объектах;
           - заполняет елементы интерфейса полученной информацией;
           - приводит кнопки в дефолтное состояние;
****** DONE Получение пути и выборки
       Варианты:
       1) selectionPathsInto:separator:
          В качестве параметров используется 'char*'. Содержит список
          путей разделенных символом, указанным в separator:.
       2) [Inspector selectedPath:files:]
          -> [NSApp selectedPath:files:]
          --> fv = [NSApp fileViewerForKeyWindow]
          ---> [fv absolutePath], [fv selectedFiles]
       3) getSelectedPath:andFiles:

       Выбран вариант 3.
       Вариант 2 пока остался для совместимости с WMInspector.
       Нужно решить, в каких случаях стоит обновлять содержимое
       локальных переменных, запрашивая новые значения у FileViewer.
       DONE: добавил ivar fileViewerSelectionChanged. Проверяется в
       getSelectedPath:andFiles: перед запросом к FileViewer.
****** DONE Внесенные изменения и смена выборки в FileViewer
       Что делать если аттрибуты объекта изменены "window broken X" и без
       нажатия на 'ok' происходит смена выборки в FileViewer. 
       Варианты:
       1) Делать 'revert' без предупреждения и загружать информацию о новой
          выборке.
       2) Выбросить alert с предложением сделать "Revert" или "Apply" и
          только после этого загружать новйю информацию о выборке.

       В OPENSTEP при смене выбранного файла в FileViewer или переключении
       между разделами инспектора (разными инспекторами) работает
       вариант #1 (изменения теряются, 'X' окна и кнопки возвращается в
       исходное состояние).
       DONE: у меня работает также, как в OPENSTEP.
***** DONE Inspectors.bundle
      _Что получилось_:
      - Inspector находится внутри Inspectors.bundle.
      - Inspector загружает .GORM в activateInspector:.
      - Built-in inspectors - наследники Inspector.
      - Contents inspectors - наследники WMInspector.
      - Все инспекторы характеризуются тем, что:
        - получают доступ к okButton, revertButton, window через вызов
          соответствующих методов (напр. [self okButton]);
        - загружают информацию об объекте в методе 'revert';
        - получают доступ к пути через 'getSelectedPath:andFiles:';
        - изменяют состояния кнопок и окна - в методах 'touch', 'ok',
          'textDidChange', 'revert';
      - При изменении активного окна FileViewer отправляет 
        [Inspector revert:].

      _Как это работает_:
      - [Controller _loadInspectors] загружает bundle и создает Inspector
      - [Controller show*Inspector] вызывает [Inspector show*Inspector]
      - Inspector ('show*Inspector:', 'selectView:', '_setInspector:'):
        - инциализирует себя в 'ativateInspector' (загружает .GORM);
        - создает один из инспекторов с помощью 'new' -> inspector
        - устанавливает заголовок окна, заправшивая у inspector -> 
          [[inpector window] title];
        - загружает view inspector'a -> [[[inspector] window] contentView];
***** DONE Множественная выборка в FileViewer
      Нужно ображать иконку MultipleSelection и правильный текст.
      Посмотреть как это сделано в PathView или использовать PathIcon.
***** DONE Длинный текст в поле 'Path:'
      Замещать троеточием слева (или справа?).
      Логично было бы замещать справа, поскольку в FileViewer видно какую-то
      часть пути с конца (справа).
      Посмотреть как это сделано в OPENSTEP: троеточие слева.
***** DONE Длинное имя файла
      В OPENSTEP: если текст не помещаяется - меняется размер шрифта.
      DONE: в _updateDisplay.
***** DONE Attributes
****** DONE NXClockView см. Frameworks->NXAppKit->NXClockView
****** DONE Работа с множественной выборкой
******* DONE Link To:
        Должно быть пусто.
******* DONE Size:
        Поле Size:, кнопка "Compute Size".
        Только файлы: показать общий объем.
        Только каталоги: пусто, кнопка активная.
        Файлы и каталоги: пусто, кнопка активная.
******* DONE Owner:, Group:
        Если значения совпадают у всей выборки показывать, иначе - прочерки.
        Кнопки активны только если разрешено и есть на что менять.
        OPENSTEP: по-разному, но в основном так же. Если параметр нельзя
        менять, PopUp превращается в TextField.
******** DONE Реализовать PopUpListCell : NSPopUpButtonCell
         Отличие от NSPopUpButtonCell:
         - при setEnable:NO - текст черный, кнопка и картинка пропадают, на
           клик не реагирует
******** DONE Owner всегда показывает прочерки при множ. выборке
******* DONE Permissions:
        OPENSTEP?
        Устанавливать поля совпадающие у всей выборки.
        - [X] для несовпадающих - показывать изоображения прочерка.
        - [X] revert не работает.
******* DONE Date:
        Ничего не придумывается. Посмотреть как это работет в OPENSTEP.
        OPENSTEP: устанавливается значение последнего выбранного файла.
        Логично было бы очищать при множественной выборке.
        DONE: отображается начало эпохи UNIX 1 Jan 1970, 00:00.
****** DONE path vs. filePath+fileSelection
       Нужно проверить правильная ли переменная используется во всех
       методах.
       DONE: Убрал использование родительского filePath и fileSelection.
***** DONE Tools
****** DONE Множественная выборка
       Показывать инспектор только если выбраны файлы одного типа.
       Иначе - 'No Tools Inspector'.
****** DONE Для каталогов показывать "No Tools Inspector"
       Через bundle.registry получать 'nodep' метод, который должен
       возвращать YES или NO.
****** DONE Double-click при множественном выборе
       ...должен открывать все файлы в приложении.
****** DONE .bundle в инспекторе 'Tools'
       ...должен показывать 'No Tools Inspector' как для каталога.
****** DONE Нелады с установкой приложения по умолчанию
       DONE: в ok: использовалась переменная path (каталог) вместо пути к
       файлу. Получалось, что устанавливается приложение по умолчанию для
       всех файлов без расширения.
***** DONE Access Control (Permissions)
      Тоже, что в "Permissions" AttributesInspector", только с помогающим
      текстом и в зависимости от типа выбранного объекта.
****** DONE Для одного объекта:
       - очищать текст вверху;
       - делать неактивным поле "Also apply to files inside selection".
****** DONE Множественная выборка
       Поведение аналогично "Permissions" в AttributesInspector.
       Менять текст вверху для нескольких случаев:
       - выбраны только каталоги
       - выбраны только файлы
       - выбраны файлы и каталоги
****** DONE Применение прав для содержимого каталогов
******* DONE "Apply to files..."
******** DONE Кнопка должна появлятся по необходимости
         - если выбран каталог
         - если выбрано больше 1 файла копка не появляется если в выборке
           нет каталога
******** DONE Отображение текста ниже
         Если галочка стоит отображается:
         "Click OK to change permissions recursively in selection"
******** DONE Применение прав если галочка стоит
         Применять для содержимого каталога рекурсивно.
****** DONE Специальные биты (SUID, GUID, sticky)
***** DONE Contents
****** DONE WMInspector
       OPENSTEP/NextDev/Reference/
       WorkspaceManager/Classes/WMInspector.htmld/index.html
       Добавил в Inspectors/Workspace.h
       Для Inspector все уже педусмотрено.
       Для WMInspector нужно получать информацию о (bundle.registry):
       - _type_ The type of registration. 
              For inspector commands, the value must be "InspectorCommand".
       - _mode_ The mode of the Inspector panel.
              For Release 3.0, this must be "contents".
       - _extension_ The file extension to be associated with this inspector.
                   (Don't include the "." in the extension.) You can only
                   list one extension for each inspector module; wildcard
                   characters aren't permitted.
       - _class_ The name of the subclass of WMInspector.
               In general, an instance of this class owns the nib file that
               contains the inspector's user interface.  Workspace Manager 
               instantiates an object of this class when the inspector is 
               loaded.
       - _selp_ The selection predicate; that is, the requirements concerning
              the selection.  The value can be either "selectionOneOnly" or
              "selectionOneOrMore".
****** DONE Находить и регистрировать contents inspectors
       Требования к WMInspector bundle:
       1. Расширение бандла может быть любым (.bundle, .inspector,
          wminspector), главное должен быть файл bundle.registry.
       2. Файл bundle.registry, содержит:
          1. type=InspectorCommand
          2. mode=contents
          3. extentsions типа NSArray
          4. priority равно -1 для дефолтного инспектора, >= 0 для всех
             остальных. Чем выше число, тем выше приоритет. Если поля нет,
             приоритет устанавливается равным 0.
       3. Расположение: 
          /Applications, ~/Applications, /Library, ~/Library.
       4. В поле class должен быть указан дочерний класс WMInspector.
******* DONE Поиск и регистрация в Inspector.m
        Информация о зарегистрированных бандлах сохраняется в переменной
        inspectorsRegistry в виде NSArray. Каждый элемент это 
        содержимое bundle.registry, дополненное полем 
        path=@"полный путь к банлу".
******* DONE Загрузка WMInpsector bundle
        Загруженные классы сохраняются в виде следующих полей в NSDictionary 
        в переменной inspectorsRegistry:
        object = объект дочернего класса WMInspector
        view = [[object window] contentView]
******* DONE Выбор contents inspector по расширению
****** DONE Folder (built-in)
       "Sort by", "Folders first"
       Сохранять в '~/Library/Preferences/Workspace.ospl' в формате
       "/Path/to/folder" = 
       {
         SortBy = *Name* | Kind | Size | Date | Owner;
         FoldersFirst = *YES* | NO;
       }
       Значения "sort method": Name, Kind, Size, Date, Owner
****** DONE Application (built-in)
       ReadOnly: инфа из Info-gnustep.plist (версия, ассоциированные файлы).
****** DONE FileInspector: Text files
       Кол-во строк, кодировка, содержимое первых строк.
       Текстовый файл определяется по mime-type (NXFileManager).
****** DONE FileInspector: multiple selection
       Показывает список выбранных объектов без каталога (просто список имен).
******* DONE OK -> Edit (открывать в TextEdit)
****** DONE Images
       Размер, % масштаба.
******* DONE OK -> Display (открывать в Review)
****** DONE RTF
       По идее, то же, что и в FileInspector, только с форматированием.
**** DONE FileViewer
***** DONE Использовать тип сортировки из defaults
      Тип сортировки устанавливается FolderInspector и завписывается в
      Workspace.ospl.
      [NXFoundation/NXFileManager sortedDirectoryContentsAtPath:path].
      Добавлена скрытая настройка DefaultFolderSortType=1; это соответствует
      NXSortByKind (folders first + NXSortByName).
      Добавлен notification: WMFolderSortMethodDidChangeNotification
      (определен в Workspace.h, присвоено значение в Controller.m).
***** DONE Enter/DoubleClick на .bundle
      ...должен делать "Open as Folder".
      В целом логика такая в getInfoForFile:application:type
      (Controller+NSWorkspace):
      - NSFileTypeDirectory:
        .app, .debug, .profile -> _NSApplicationFileType_
        .bundle -> _NSPlainFileType_
      - NSFileTypeRegular -> _NSShellCommandFileType, NSPlainFileType_
      - все для чего есть ассоциированные приложения -> _NSPlainFileType_

      Итого, если каталог воспринимается как wrapper, но при этом не
      является приложением должен обрабатываться специальным образом во всех
      соответствующих методах NSWorkspace.
      Возможно имеет смысл составить список таких wrapper'ов для того, чтобы
      они открывались как каталоги. 
      OPENSTEP для таких wrapper'ов ничего не делает.
***** DONE Folder viewer для wrappers
      Неправильно отображается путь в PathView (две иконки с .app или
      .bundle).
      [FileViewer validateAndDisplayPath:selection:] в случае, если selection
      пустой переносит последний компонент в пути в selection. В случае 
      открытия wrapper'a в результате имеем: путь=@"/" selection=@"/".
***** DONE "Open as Folder" должен активизировать существующее окно
      DONE: 
      - активизируется существующее окно.
      - для Folder Viewer устанавливается запомненный путь из
        "ViewerPath" (.dir)

      Если такая функциональность не реализуется, тогда при открытии
      нужно:
      - поверять открыто ли уже окно с таким каталогом (rootPath);
      - сдвигать несмотря на наличие сохраненной геометрии в .dir
        если предыдущая проверка подтвердила наличие уже открытого окна.

      Это нужно для того, чтобы новые открывающиеся окна одного и
      того же каталога не перекрывали друг друга полностью.
***** DONE Изменение ширины окна FolderViewer
      Поведение при изменении ширины окна или ширины колонки viewer'a
***** DONE Иконки PathView и Shelf
      Поведение иконок PathView и Shelf при манипуляции мышкой 
      (click, double-click, drag).
****** DONE Double-click на каталоге в PathView: 
       Должен устанавливаться путь на этот каталог (загрузка
       содержимого каталога во viewer, изменение пути в PathView)
****** DONE При перетаскивании нужно оставлять выделенной source иконку.
       Выделенная иконка дложна оставаться выделенной до отпускания
       кнопки мыши.
****** DONE Сделать PathIcon:XSIcon с поведением, которое подходит и для Shelf и для PathView.
****** DONE Глюк с иконками PathView
       Был какой-то глюк с иконками (нарисовалась иконка файла вместо 
       каталога) в root FileViewer и размножением колонок в Browser после 
       перетаскивания... Повторить не удалось.
****** DONE Drag&Drop
******* DONE иконки с множественным выбором
******* DONE в/из folder viewer'a
******* DONE оптимизировать код установки перемненной paths для иконок
******* DONE перемещение между viewer'aми
        При перемещении между FileViewer и FolderViewer в один и тот же
        каталог файл удаляется(если выбрать 'Overwrite' в Alert)! По идее не
        должно давать drop'ать иконку если
        source_folder==destination_folder.
**** DONE Browser
***** DONE Короткие имена ("LongFileNa...")
      Короткие имена файлов/каталогов, не помещающихся в заданную ширину 
      (browser) их переименование.

      Возможно стоит вынести в framework NX*. Такая функциональнсть
      будет нужна в BrowserViewer, PathIcon, Inspector,
      Processes->Background и вобще в любом месте где нужно изящно
      отобразить текст не помещающийся в NSView.

      Есть реализация в Processes.m, cutText().
      Есть что-то похожее в:
      + FileSystemInterface.m, 
        collapsedPathForPath:viewWidth:viewFont:dotsAtLeft.
      + NXIcon (NXAppKit), rebuildCollapsedString.

      DONE: Сделал в NXAppKit/NXUtilities.[hm] функциию shortenString().
      DONE: Теперь ей нужно воспользоваться.
      DONE: Нужно сделать, чтобы работало в FolderViewer
***** DONE Symlinks отображать шрифтом Italic
***** DONE ширина колонки из настроек
***** DONE расчет количества колонок
***** DONE расчет размера окна на базе ширины колонки
***** DONE настойка ширины колонки в Preferences->Browser
**** DONE Processes, FileOperation
***** DONE Отображение FileOperation
****** DONE Управление Tools/FileOperation
******* DONE Количество файлов в операции
        Если встречается ссылка на каталог и выбрано "copy the
        original" количество файлов нужно пересчитывать.
******* DONE Возврат ФС в исходное состояние при останове
        Все операции должны быть недеструктивными - если что-то
        произошло в процессе операции произошло какое-то событие,
        требующее действий от пользователя - просто остановить операцию.
          - [X] Move - перемещает файлы в исходное расположение.
                Не удалось протестировать - слишком быстро.
          - [X] Link - убирает созданные линки в целевом расположении.
                Не удалось протестировать - слишком быстро.
          - [X] Copy|Duplicate - удаляет целевой файл|каталог.
          - [X] Delete - ничего не делает.
******* DONE Останов FileOperation
        FileOperation должен останавливаться:
          - Коммандой Communicator'у ('t'). FileOperation завершается,
            Processes должен только регистрировать завершение процесса.
          - [NSTask interrupt] посылает сигнал SIGINT, FileOperation ловит
            сигнал и завершает работу, Process регистрирует завершение
            FileOperation.
        NOTE: Метод NSTask -terminate помечает task как hasTerminated
        (-isRunning возвращает NO), -interrupt не помечает, поэтому лучше
        использовать -interrupt. Это нужно для того, чтобы Process
        закончил читать вывод FileOperation.
******* DONE Отображение состояния FileOperation
        Текст состояния процесса должен возвращаться процессом, Process
        должен только отображать "Sizing...", "Copying ...", "File
        Operation Completed", "File Operation Stopped".
******* DONE Название полей "From:" и "To:"
        - [X] BatchSize - "Sizing <filename>" From: sourceDir To: targetDir
          sourceDir меняется, targetDir не меняется
        - [X] Copy - "Copying <filename>" From: sourceDir To: targetDir
        - [X] Move - "Moving <filename>"  From: sourceDir To: targetDir
        - [X] Link - "Linking <filename>" From: sourceDir To: targetDir
        - [X] Delete - "Destroying <filename>" In: sourceDir
        - [X] Duplicate - "Duplicating <filename>..." From: sourceDir To: targetDir
****** DONE При дублировании ~/Developer/CUBE залипает!
       Особый случай: в пути встретился symlink, указывающий на '.'.
       На каком-то очередном витке раскручивания symlink
       Tools/FileOperation ловит ситуацию UnknownFile.

       Непонятно другое: почему нет alert panel?
       DONE: не было fflush() после printf.
****** DONE Добавить обработку операций с ссылками на текущий каталог
****** DONE Операция с линком на несуществующий файл
       Если выбрано "Copy", нужно предлагать сделать новый линк (New
       Link).
***** DONE Autosizing таблицы с background процессами
      При нестандартном размере окна с самого начала, ширина колонок
      неправильная. Нужно, чтобы выравнивалась по ширине таблицы.
      DONE: Добавил -windowDidResize: в -setView.
***** DONE Четвертая левая кнопка в Background
      Если был показан alert с тремя кнопками, затем с четырмя
      (например, сначала FileExists, затем SymbolicLink) левая кнопка
      ('Follow' при SymbolicLink) оказывается прижатой к левому краю.
      DONE HACK: [FileOperation updateOperationView]: При добавлении
      кнопки вычислять расположение кнопки по X отталкиваясь от
      расположения предыдущей кнопки.
      На самом деле это больше похоже на баг GNUstep. Получается, что
      subview, который не был ни разу не показан на экране пропускает
      все эволюции размеров superview. Как следствие координаты
      subview устаревают.
***** DONE Надпись "No Background Process"
      Нужно сделать центрирование надписи "No Background Process"
***** DONE Applications: навигация клавиатурой
      При навигации по списку процессов клавиатурой не меняется
      информация о приложении
***** DONE "Background": таблица списка процессов всегда должна быть видна
***** DONE Короткие имена объектов 
      ...в полях 'From','To', текущем файле, списке процессов.
***** DONE Progress bar
****** DONE Обычный progress bar с черточками (MiscKit)
****** DONE Круговой progess bar (MiscKit)
***** DONE Выход из Workspace и активные процессы в "Background"
      При выходе из Workspace, остающиеся фоновые процессы начинают
      грузить процессор.
***** DONE Переключение между прогрессом операции и FileOperationAlert
      Не переключается на прогресс операций после обработки запроса
      (FileOperationAlert)
***** DONE Вид списка фоновых операций
      Статус должен выравниваться вправо.
      Пропорции колонок должны быть другими.
***** DONE Размер иконок в операциях Background
      Иконка Move не помещается в строку таблицы по вертикали.
      DONE: Увеличил высоту строки до 20.
**** DONE Сохранять путь, включая выделенный файл
**** DONE Навести порядок с методамы drag&drop
     В протоколе NSDragging есть только
     draggingSourceOperationMaskForLocal:.
     Классы NXAppKit (NXIcon, NXIconView) транслируют этот метод в:
     - draggingSourceOperationMaskForLocal:icon:(для NXIcon)
     и
     - draggingSourceOperationMaskForLocal:inView (для NXIconView).

     Нужно разобраться где и как должны лежать/транслироваться методы:
     - draggingSourceOperationMaskForLocal:icon:
     - draggingSourceOperationMaskForLocal:iconView:
     - draggingSourceOperationMaskForPaths:(сейчас в FileSystemInterface)
     - draggingDestinationMaskForPaths:intoPath:(сейчас в
       FileSystemInterface)

     DONE: Закомментировал все диспетчерские методы за исключением
     draggingSourceOperationMaskForLocal:. Предполагается, что
     остальные методы должны диспетчится 'delegate' дочерними классами
     NXIcon и NXIconView.
**** DONE Манипуляции с файлами в Workspace и ОС
***** DONE Реализовать операцию 'Relink' в Tools/FileOperation
      DONE: Теперь нет 'Relink'. Есть "Copy" - copy original и 
      "New Link" - make new link.
***** DONE Настройка действий по умполчанию при файловых операциях
      Внутри инструмента FileOperation есть несколько опций:
      * DefaultReadErrorAction: SKIP|skip
      * DefaultWriteErrorAction: SKIP|skip
      * DefaultDeleteErrorAction: SKIP|skip
      * DefaultMoveErrorAction: SKIP|skip
      * *DefaultSymlinkAction: COPY|copy, RELINK|copy, FOLLOW|follow*
      * DefaulAttributesUnchangeableAction: IGNORE|ignore
      * DefaultFileExistsAction: OVERWRITE|ovwerite, SKIP|skip
      * DefaultUnknownFileAction: SKIP|skip
      Значения действий написанный капсом - применить для всех подобных
      ситуаций. Маленькими - только для текущего файла.
      В Alert диалоге меняется установкой галочки 'Repeat'.

      С точки зрения опций в Preferences имют смысл: DefaultSymlinkAction,
      поскольку это не деструктивная операция. К другим должно быть
      привлечено внимание пользователя. В случае с FileExist пользователь
      должен принять решение, Alert при других операциях позволяет
      остановить файловцю операцию.

      Для Symlink не совсем понятно чем отличается COPY от RELINK. Наверное
      это имеет RELINK имеет смысл только для hard links. Тогда эту опцию
      логично было бы предоставлять только для hard links.
***** DONE Сообщения в alert панели операции
      Где должны генериться? Варианты:
      1. FileOperation/*.m
      2. FileOperation.m -report*
      3. FileOperation -updateOperationView* с учетом problemDesc из
         -report*
      Пока кажется, что должны генериться внутри методотов
      FileOperation.m report* (например, reportSymlink).
****** DONE Сделать генерацию сообщений в методах -report*
****** DONE В сгенерированных alert-сообщениях неправиольные пути
       При генерации сообщений, например, берется 'sourceDirectory' и
       прибавляется 'filename'. Но файл может быть намного ниже
       'sourceDirectory'.
       *Решение*: для имени каталога нужно использовать переменную
       'source'. Эта переменная наполняется из вывода утилиты
       FileOperation.
****** CHECK ivar 'filename' должна быть пустой если операция с каталогом
***** DONE Панель операции Delete: не нужно писать "To:"
***** DONE Не работает File->Duplicate
      - [X] добавить в FileOperation операцию дублирования
      - [X] использовать новую функциональность в FileViewer
***** DONE Создание каталога в FolderViewer
      При создании каталога в FolderViewer в относительном корне
      (первый столбец):
        + 'NewFolder' не появляется в первом столбце;
        + 'NewFolder' не подсвечивается в Browser'e;
          Добавил reloadPath в BrowserViewer displatPath:selection:.
        + созданный каталог не подсвечивается в Browser после создания.
***** DONE Переменная displayedPath в FileViewer
      В FileViewer многое завязано на displayedPath. Пересмотреть
      подход к определению отображаемого пути.
***** DONE Сохранение позиции во Viewer
      При переименовании файла/каталога и обновлении содержимого каталога должен 
      сохранятся выбранный объект с сохранением позиции скролла.
***** DONE Обновление содержимого каталогов после операции
****** DONE Если открыто 2 окна с одинаковым выбранным каталогом
       ...при изменениях каждым обрабатывается событие 2 раза -
       Переписан NXFileSystem: при добавлении, путь разбирается на
       компоненты и добавляются к мониторингу все каталоги в
       пути. Внутри NXFileSystem сохраняется количество добавление
       для каждого каталога в пути и уменьшается при удалении пути из
       мониторинга.
****** DONE удаление:
******* DONE последнего выбранного элемента пути, одного из промежуточных выбранных элементов пути)
        выбрать последний существующий элемент
******* DONE одного из элементов множественного выбора
        снять множественное выделение и выбрать предыдущий элемент пути (каталог).
****** DONE изменилось содержимое каталога (перемещение, копирование, удаление):
******* DONE без изменения элементов выбранного пути
        обновить список без изменения выделения
******** DONE для активного окна
******** DONE для другого окна
******* DONE с изменением элементов выбранного пути (удаление, перемещение)
        выбрать последний существующий элемент пути.
******** DONE для активного окна
******** DONE для другого окна
****** DONE переименование файла:
******* DONE из Workspace (последний элемент пути)
******** DONE для активного окна
******** DONE если файл выбран в другом окне
         Выбирается передыдущий каталог и обновляется содержимое каталога
******* DONE из ОС - событие от NXFileSystem - Write
        Если файл/каталог выделен, выбирается предыдущий каталог.
        Если файл не выделен - обновляется содержимое каталога.
****** DONE переименование каталога:
******* DONE из Workspace
******** DONE для активного окна: если сначала был выбран файл, затем каталог (в PathView 1 пустая колонка), затем каталог переименован - неправильно отображается PathView (или Browser)
******** DONE если каталог выбран в другом окне
         Выбирается предыдущий каталог
******* DONE из ОС - событие от NXFileSystem - Write
        Выбирается предыдущий каталог
****** DONE переименование одного из объектов из множественного выделения в другом окне
       Содержимое каталога обновляется, переименованныц файл убирается из выделения.
***** DONE Переименование файла/каталога
      Проверять наличие файла с новым именем и спрашивать о замене
***** DONE При открытии пустого FolderView 
      ...неправильно определяется количество иконок в PathView
      (появляется скроллер) или выполнить такую последовательность
      действий:
        * создать каталог
        * открыть с помощью 'Open as Folder'
        * клинкуть на скроллере
**** DONE Shelf
***** DONE Настройки для Shelf
****** DONE Resizable Shelf
****** DONE Перенести реализацию ArrowView в NXAppKit (NXSizer)
****** DONE Использовать NXSizer в Preferences
      - Browser
      - Shelf
      - Icon View
****** DONE Сделать копию Preferences/IconView в Preferences/Shelf
****** DONE Title Width
       Размер Shelf неправильно пересчитывается. См. положение dimple.
****** DONE Сокращенное имя
****** DONE Восстанавливание размера Shelf в FolderViewer
       Вычитывание и установка из .dir.
***** DONE Количество иконок в Shelf (по горизонтали)
      Shelf должен вмещать по ширине только целое количество иконок
      (при перетаскивании слот помещающийся в окно частично не
      должен показывать полупрозрачную иконку и приниматься Shelf).
      DONE: [NXIconView resizeWithOldSuperviewSize], roundf->floorf.
***** DONE Изменение размеров SplitView и Shelf
      При изменении размера SplitView, Shelf должен подстраивать свой
      размер. Сейчас при увеличении Shelf иконки нельзя перетащить в
      появившееся пустое место Shelf.
***** DONE Размер SplitView при старте
      Размер SplitView в части Shelf показывается некорректно при
      старте Workspace
***** DONE Неудаляемая иконка FileViewer.
      Root Viewer должен содержать неудаляемую иконку домашней
      директории пользователя.
      Folder Viewer должен содержать неудаляемую иконку корневого
      (для Folder Viewer) каталога.
***** DONE Проверить различные операции Drag&Drop на корректность:
****** DONE Внутри Shelf
******* DONE После перетаскивания иконки другая остается выбранной.
******* DONE Root-иконка может быть удалена.
******* DONE Если перетаскиваемая иконка по пути попадает на пустое место в Shelf - не удаляется.
****** DONE После выбора (click) иконки и следующего удаления другой, ранее выбранная иконка подсвечивается как выбранная.
****** DONE Проверить перетаскивание иконок между Shelf'ами разных окон. Всё OK: принимаются пути, которые находятся в области видимости FolderViewer'a.
***** DONE Должна ли устанавливаться минимальная ширина окна если Shelf не resizable?
      Нет. В OPENSTEP иконки, которые не помещаются при уменьшении размера окна просто не показываются.
***** DONE Двойной клик на иконках
      При двойном клике на приложениях, они должны запускаться (сейчас отрабатывает "Open as Folder")
**** DONE PathView
***** DONE Что-то глючит при выборе файла в корне после выбранного длинного пути
***** DONE Артефакты при добавлении новых иконок
      ...появляются какие-то артефакты при добавлении новых иконок
      (пропадают при дергании scroller knob)
      ...похоже это связано с перерисовкой IconView(PathView) внутри
      scrollView; 
      HACK: добавил setNeedsDisplay:YES для scrollView в
      FileViewer displayPath:...
      Убрал HACK, проверил. Вроде все нормально.
***** DONE Скроллинг PathView в FolderViewer
      Скроллинг PathView в FileViewer (Root, Folder) глючит при
      количестве колонок - 2.
      Проблема была в обновлении переменной количества колонок внутри
      BrowserViewer.
***** DONE Количество пустых иконок в PathView
      Проблема: при уменьшении окна по горизонтали количество пустых иконок в PathView
      не меняется.
      Решение: кусок кода из [FileViewer displayPath:selection:sender:] скопировал
      в [FileViewer windowDidResize].
****** DONE Создать метод для синхронизации пустых иконок/колонок
       Нужно подумать о вынесении кода по синхронизации пустых иконок/колонок 
       viewer и PathView в отдельный метод.
       Сделано: pathViewSyncEmptyColumns
*** Версия > 1.0 [0/11]
    :PROPERTIES:
    :COOKIE_DATA: todo reccursive
    :END:
**** TODO CInspector
     Инспектор для .c, .h и .m файлов.
**** TODO Sound Contents Inspector
**** TODO Показывать в инспекторе 'Tools' contents Inspector
     Объекты для которых есть Content Inspector показывать иконку и
     .bundle Content Inspector'a.
**** TODO Finder - поиск файлов
     По дате, владельцу, размеру, содержимому.
**** TODO Реализовать все нереализованные методы NSWorkspace (//FIXME)
     В первую очередь те, которые OpenStep-compliant (помеченные FIXME и
     недостаточно корректно/полно реализованные).
**** TODO Реализовать File->Compress
     Простой compress без опций или сложных способов и прогресса:
     - gzip/xz для одного объекта;
     - tar.gz/tar.xz для многих объектов.
**** TODO Автоматически обнаруживать новые приложения
     После появления нового приложения в каталогах /Applicaitons,
     ~/Applications. Что хотелось бы:
     1. Пользователь копирует приложение в /Applications,
        ~/Applications;
     2. Workspace узнает через NXFileSystem;
     3. Workspace запускает обновление информации о приложениях
        (make_services) и обновляет меню 'Services'.
**** TODO Viewers - отображение копируемых/перемещаемых объектов серым цветом пока процесс не завершен
**** TODO Разместить исходники настроек viewer'ов рядом с исходниками viewer'ов
*** Когда-нибудь [0/10]
**** TODO Application content inspector (AppInspector)
     Добавить отображение сервисов, предоставляемых приложением.
**** TODO Content inspector для .so, binary executable, shell
     Под вопросом. Нужно ли?
**** TODO FileViewer: Конфигурационые файлы
     Содержимое .dir и preferences приложения: подумать как можно
     перераспределить. Оригинальный WorkspaceManager не хранит свои
     настройки в виде доступном команде 'defaults'.
     
     Не создавать '.dir' в программных бандлах (.gorm, .app)
**** TODO Анимация возврата иконки в Shelf
     При помещении объекта в Shelf иконка должна плавно скользить на место.
**** TODO Processes->Background: имена в полях From: и To:
     При манипуляциях с объектами с длинными путями текст в полях
     From: и To: не всегда отличается. Нужно подумать на предмет
     реализации сокращения с точками внутри. 
     Задачка не совсем простая, поскольку нужно решить какие части
     начала и конца пути стоит оставлять (и самое главное, как это
     определить программно!).
**** TODO Отчет о проблемных (Alert) файлах после завершения операции
**** TODO Работа с архивами (+ отображение в Processes-Background processes), OpenUp?
**** TODO Работа с сетевыми ФС: CIFS, NFS, FTP, SFTP (/Net?)
**** TODO (нужно ли?) Операции с файлами/каталогами через меню "Edit"-> Cut, Copy, Paste, Delete


** 3. Preferences
*** DONE Работа с бандлами .preferences
    Все модули должны иметь заполненный bundle.registry и устанавливаться в
    Preferences.app/Resources.
    Протокол для бандлов лежит в /usr/NextSpace/apps/Preferences.h.
*** DONE Появление/скрытие окна
*** DONE Отображать иконки с учетом priority из bundle.registry
*** TODO Модули
**** DONE Fonts: GNUstep font settings
     back-art-subpixel-text всегда устанавливается в '0'.
     Пробовал другие значения - разницы не заметил.
**** DONE Localization: language, units, paper, encoding
     Есть идея заменить 'Text Encoding' на 'Paper Size', а 'Keyboard' вынести
     в модуль 'Keyboard' в таб 'Layouts'. Вместо 'Keyboard' редактировать
     разные настройки International: первый день недели, формат даты/времени,
     валюта и т.д.
     Значения достаются через [NSUserDefaults] читается в след. порядке:
     - из NSGlobalDomain;
     - из Languages/<первый элемент массива из NSLanguages>.
***** DONE Language
      NSLanguages = (English, Russian, Ukrainian)
****** DONE Отдельный виджет
       ...с перетаскиваемыми языками, но не так, как это сделано в NSTableView.
****** DONE NSScrollView с documentView в виде NSMatrix.
****** DONE Менять местами языки после перетаскивания
****** DONE Прокручивать список при приближении перетаскиваемого языка
***** Text Encoding
      Опеределяется автоматически, либо через переменную окружения
      GNUSTEP_STRING_ENCODING.
      В Text Encoding нет смысла: по сути эта настройка управляет чтением
      строк C в объекты ObjC. По умолчанию должно быть UTF8 (для чтения имени
      файлов и т.д.). Во всех других случаях (например, чтение содержимого
      текстового файла в какой-то специфической кодировке должно делать
      приложение).
***** DONE Measurement Unit
      NSMeasurementUnit = Centimeters | Inches | Points | Picas
***** DONE Обновлять примеры форматов после смены в списке языков
**** TODO Display: resolution, layout, gamma correction, wallpaper/color
***** DONE Изменение настроек не должно влиять на плавность изменения контролов
      Использовать dispatch & blocks?
      Вся проблема во множественных вызовах [NXScreen randrScreenResources].
      Сделал, чтобы NXDisplay кешировал screen_resources.
***** DONE Сохранять изменения в ~/Preferences/Displays.config
***** DONE Если есть ~/Preferences/Displays.config - применять при старте
***** DONE Перечитывать список мониторов после изменений
      NXScreenDidChangeNotification посылается Workspace как результат
      получения Notify от XRandR в EventLoop(). Который, в свою очередь
      отправляется только при изменении Screen (изменение разрешения, on/off
      мониторов, в т.ч. и подключение/отключение).
      При изменении атрибутов мониторов (gamma, brightness, properties) XRandR
      Notify не генерируется.
***** DONE В VirtualBox двигание слайдеров = залипание/падение
      В текущей версии - все нормально. Возможно какие-то изменения в ядре? ХЗ.
***** DONE Установка Brightness
***** DONE Ввод только цифр и точки в текстовые поля (gamma, brightness)
      Стоит реализовать в NXAppKit. После реализации в NXAppKit использовать
      здесь.
***** TODO Отложенное сохранение настроек для gamma и brightness
***** TODO Получать и изменять фон рабочего стола -> NXDisplay
      Не нашел возможности простого получения текущего цвета окна X11.
      Поэтому, сейчас предполагаю, что цвет был установлен такой, который
      сохранен где-то в  ~/Library/Preferences.
***** TODO Установка Backlight (если монитор поддерживает)
**** TODO Screen: displays layout, on/off
***** DONE Устанавливать 'Main Display'
***** DONE Активировать/деактивировать монитор
***** DONE Принимать уведомления об измнениях в конф. мониторов
***** TODO Перемещение мониторов мышкой
****** TODO Прилипание одного к другому
****** TODO Выравнивание во время перетаскивания
***** TODO Отображение мониторов
****** DONE Показывать отключенный монитор
****** DONE Arrange (метод и кнопка)
       Нажатие на кнопку возвращает display boxes в исходное состояние.
****** DONE Отображение Dock и Icon Yard на 'Main Display'
****** TODO Получать и отображать desktop background
       Нужно сначала реализовать это в модуле Display.
**** TODO UNIX Expert
     Используется Workspace Manager'ом.
***** TODO Нарисовать панель
**** TODO Keyboard: (Command, Alternate), repeat rate, shortcuts
**** TODO Mouse: acceleration, pointers, количество линий при прокручивании колесом
**** TODO Sound: input and output settings, system beep sound
***** TODO Нарисовать панель
**** TODO Network
***** TODO Нарисовать панель
**** TODO Power: screensaver, display dimming (или в дисплей?)
**** TODO Login: screensaver, hooks, display hostname
**** TODO Date & Time
***** TODO Нарисовать панель
**** TODO Password/Users?
**** TODO Services: enable/disable
***** TODO Нарисовать панель
*** TODO WindowMaker settings
**** TODO Настройки GNUstep и WindowMaker
     Нужно думать как организовать работу так, чтобы ничего не забыть.
**** TODO Menu, Dock, icons
     - Default menu location;
     - WindowMaker Dock settings: Dock position, hiding, etc.
     - Dock placement on multi-monitor configuration = on Main Display;
     - Bottom icons placement = on Main Display;
**** TODO Window management
*** TODO .preferences как документ открываемый Preferences
*** TODO Все модули должны подстраиваться под размер окна
*** TODO Старт без без появления меню


** 4. Terminal
*** TODO 1.0
**** DONE Terminal падает на CentOS 7
     Возможно из-за int->NSInteger?
**** DONE Изменение размера окна и положение курсора
     Сейчас при увеличении размера окна курсор и приглашение shell прыгает
     вниз, а должен оставаться на месте.
**** DONE Расположение на экране новосозданных окон
     Сделал собственное управление появление окон. cascadeTopLeftFromPoint 
     мне не нравится.
**** TODO Preferences
***** DONE Переключение между разделами
      Не должны сбрасываться настройки, которые были изменены?
      В OPENSTEP сбрасываются. Пока оставим и здесь так.
***** TODO При изменении шрифта пересчитывать Bold...
      ...если в Color стоит галочка.
***** DONE Архитектурное
      Preferences:
      - содержит названия всех параметров из defaults;
      - возвращает параметры из defaults (или значения по-умолчанию);
      - загружает Preferences.bundle и активирует панель;
      Preferences/PreferencesPanel:
      - управляет панелью;
      - сождержит информацию о режимах (разделах);
      - переключает режимы (разделы);
      Preferences/*Prefs:
      - управляет именованным режимом (Show Default, активности по изменениям
        среди элементов режима);
      - отправляет notification об изменениях (Set Window);
      - сохраняет установленные значения (Set Default);
***** DONE Display
****** DONE Кнопка "Set Window"
******* DONE Нужно прятать/показывать scrollbar у окна при изменении параметра "Enabled".
******* DONE Scroll to the bottom of the window when input is received
****** DONE После установки "Enabled в ""Scrollback Buffer"...
       ...Terminal падает при первом заполнении буфера.
****** DONE Scrollback Buffer
       Нужно сделать, чтобы пункт меню был активен только если буффер ненулевой
       длинны. Проблема в том, что этот пункт находится в специальном подменю
       "Edit" delegate, которого не Controller.
       Target для пункта меню это и есть валидатор, в нем нужно создавать
       метод validateMenuItem.
***** DONE Title Bar
****** DONE Include these Elements
****** DONE Set Window
****** DONE Custom Title
       После Enter от поля 'Custom Title'.
***** DONE Window
****** DONE Кнопка "Set Window"
****** DONE When Shell Exits
       Нужно ловить выход shell/programm и смотреть exit code.
******* DONE Регистрация выполняющегося процесса 
        Отображение в виде поломанного крестика в заголовке.
****** DONE Window Size
****** DONE Font
***** DONE Linux Emulation
***** DONE Shell
***** DONE Startup
****** DONE When Terminal Starts Up
***** DONE Colors
****** DONE Cursor
****** DONE Window
****** DONE Text
****** DONE Черный шрифт на белом фоне by default
**** TODO Services
***** TODO Панель Info->Terminal Services...
***** TODO Проверить корректность работы различных параметров
***** TODO Проверить типы создания окон (shell, program)
**** TODO Info Panel
     С прокручивающимся текстом в иконке терминала. ;)
*** TODO > 1.0
**** TODO Preferences -> Title Bar -> Xterm Title
     От программ типа MidnightCommander.
     [TerminalView ts_setTitle] вызыввается только если TERM=xterm.
**** TODO Preferences -> Display -> Scrollback Buffer
     Сейчас значение Unlimited приводит к установке значения lines=1024.
     Нужно реализовать lazy механизм выделения памяти.
**** TODO Preferences- > Display -> Wrap lines that are too long
**** TODO Preferences -> Startup
***** TODO Auto-Launch
***** TODO Startup File
**** TODO Preferences -> Colors -> Cursor -> Blinking
**** TODO Activity monitor (+Preferences section)
**** TODO White on Black
     Для приложений, который действительно хотят белое на черном (в режиме,
     когда у терминала режим BlackOnWhite) нужно как-то определять, что
     действительно хочет приложение (MC, top и т.д.).
     Linux console по-умолчанию рисует белым по черному.
     Это основная логика парсера. Может нужо поменять?
**** TODO Пункты меню
***** TODO Edit->Find
***** TODO Edit->Select All
***** TODO Font
      Устанавливать шрифт и цвета для main window.
***** TODO Shell->...
**** TODO Сессии с поддержкой SSH


** 5. TextEdit
*** TODO Минимум
**** TODO Режимы редактирования: Text, Developer
     Наработки режима Developer использовать в редакторе ProjectCenter.
**** TODO TXT (plain text)
***** TODO BUG: Сохраняет лишние символы в начале plaintext файла
***** TODO Кодировки
***** TODO Ширина текста: автоматический перенос слова
**** TODO RTF, RTFD
***** TODO Найти и изучить описание стандарта на RTF
***** TODO Вставка изображений
*** TODO Максимум
**** TODO Списки
**** TODO Таблицы
**** TODO Стили
*** Полезное
    * Get the number of lines of text in an NSTextView?
    http://www.cocoabuilder.com/archive/cocoa/155182-get-the-number-of-lines-of-text-in-an-nstextview.html


** 6. Preview
*** TODO Просмотр картинок
**** TODO Просмотр всех картинок в каталоге
*** TODO Scale, rotate
*** TODO Конвертирование между форматами (PNG,TIFF,JPEG,GIF,XPM)
*** TODO Просмотр PDF, PS, EPS
*** TODO Content Inspector для Workspace
    изображение, размер, дата съемки, EXIF?


** 7. NoteBook
   Программа для ведения заметок, проектов, действий.
   Типа: OmniFocus, Emacs Org mode.


** Разное
*** TODO Отображение текущего workspace'а в иконке WorkspaceManager
*** TODO Индикатор нагрузки на CPU, использование swap
*** TODO Индикатор состояния/скорости сети (Ethernet, WiFi)
*** TODO Индикатор погоды: температура, влажность
*** TODO Что делать с systray индикаторами приложений GNOME, KDE?

